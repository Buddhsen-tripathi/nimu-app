================
CODE SNIPPETS
================
### Install BullMQ using npm or yarn

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

Instructions for installing the BullMQ library using either npm or yarn package managers. No specific inputs or outputs, just the command to add the dependency.

```bash
$ npm install bullmq
```

```bash
$ yarn add bullmq
```

--------------------------------

### Add bullmq-otel package to project

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/getting-started.md

Installs the `bullmq-otel` package, which provides an implementation of BullMQ's telemetry interface for the OpenTelemetry standard. This is the first step to enabling telemetry in your BullMQ project.

```bash
npm add --save bullmq-otel
```

--------------------------------

### Install BullMQ with Yarn

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/install.md

Installs the BullMQ library and its dependencies using Yarn. This command adds BullMQ as a production dependency to your project.

```bash
yarn add bull
```

--------------------------------

### Setup OpenTelemetry OTLP Exporter for Consumer (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

This script initializes the OpenTelemetry SDK for the consumer service. It configures an OTLP trace exporter and a periodic metric reader with an OTLP metric exporter, similar to the producer setup, but with 'consumer' as the service name. Requires '@opentelemetry/sdk-node', '@opentelemetry/exporter-trace-otlp-proto', '@opentelemetry/exporter-metrics-otlp-proto', and '@opentelemetry/sdk-metrics' packages.

```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-proto';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';

const sdk = new NodeSDK({
  serviceName: 'consumer',
  traceExporter: new OTLPTraceExporter({
    url: 'http://127.0.0.1:4318/v1/traces'
  }),
  metricReader: new PeriodicExportingMetricReader({
    exporter: new OTLPMetricExporter({
      url: 'http://127.0.0.1:4318/v1/metrics'
    }),
  }),
});

sdk.start();
```

--------------------------------

### Install BullMQ with Npm

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/install.md

Installs the BullMQ library and its dependencies using npm. This command adds BullMQ as a production dependency to your project.

```bash
npm install bull --save
```

--------------------------------

### Install BullMQ TypeScript Definitions with Yarn

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/install.md

Installs the TypeScript type definitions for BullMQ using Yarn. This is typically done for development purposes and adds the types as a dev dependency.

```bash
yarn add --dev @types/bull
```

--------------------------------

### Install BullMQ TypeScript Definitions with Npm

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/install.md

Installs the TypeScript type definitions for BullMQ using npm. This is typically done for development purposes and adds the types as a dev dependency.

```bash
npm install @types/bull --save-dev
```

--------------------------------

### Setup OpenTelemetry OTLP Exporter for Producer (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

This script initializes the OpenTelemetry SDK for the producer service. It configures an OTLP trace exporter and a periodic metric reader with an OTLP metric exporter, both pointed to a local Jaeger instance. Requires '@opentelemetry/sdk-node', '@opentelemetry/exporter-trace-otlp-proto', '@opentelemetry/exporter-metrics-otlp-proto', and '@opentelemetry/sdk-metrics' packages.

```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-proto';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';

const sdk = new NodeSDK({
  serviceName: 'producer',
  traceExporter: new OTLPTraceExporter({
    url: 'http://127.0.0.1:4318/v1/traces'
  }),
  metricReader: new PeriodicExportingMetricReader({
    exporter: new OTLPMetricExporter({
      url: 'http://127.0.0.1:4318/v1/metrics'
    }),
  }),
});

sdk.start();
```

--------------------------------

### Create and add jobs to a BullMQ queue in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

This snippet shows how to initialize a BullMQ queue and add jobs to it. It requires a running Redis instance. The input is job data, and the output is jobs added to the queue.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

async function addJobs() {
  await myQueue.add('myJobName', { foo: 'bar' });
  await myQueue.add('myJobName', { qux: 'baz' });
}

await addJobs();
```

--------------------------------

### Integrate OpenTelemetry Telemetry with BullMQ Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/getting-started.md

Shows how to add OpenTelemetry telemetry to a BullMQ Queue instance. It imports the `Queue` class from 'bullmq' and `BullMQOtel` from 'bullmq-otel', then instantiates the queue with a telemetry configuration.

```typescript
import { Queue } from 'bullmq'
import { BullMQOtel } from "bullmq-otel";

const queue = new Queue("myQueue", {
  connection: {
    host: "127.0.0.1",
    port: 6379,
  },
  telemetry: new BullMQOtel("simple-guide"),
});
```

--------------------------------

### Install BullMQ Pro Package

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/install.md

Demonstrates how to add the BullMQ Pro package to your project using common package managers like Yarn. This command fetches and installs the necessary files for BullMQ Pro.

```shell
yarn add @taskforcesh/bullmq-pro
```

--------------------------------

### Scheduling Repeated Jobs with BullMQ Cron (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Demonstrates how to schedule jobs to be processed repeatedly at specified intervals using cron specifications. Includes an example of defining a cron job and adding it to the queue.

```javascript
paymentsQueue.process(function (job) {
  // Check payments
});

// Repeat payment job once every day at 3:15 (am)
paymentsQueue.add(paymentsData, { repeat: { cron: "15 3 * * *" } });


```

--------------------------------

### Handling BullMQ Queue Events (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Provides an example of how to listen for and handle various events emitted by a BullMQ queue, such as the 'completed' event, which fires when a job finishes successfully.

```javascript
myqueue.on('completed', function (job, result) {
  // Job completed with output result!
})

```

--------------------------------

### Integrate OpenTelemetry Telemetry with BullMQ Worker (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/getting-started.md

Demonstrates integrating OpenTelemetry telemetry into a BullMQ Worker. It imports the `Worker` class from 'bullmq' and `BullMQOtel` from 'bullmq-otel', configuring the worker with telemetry enabled.

```typescript
import { Worker } from "bullmq";
import { BullMQOtel } from "bullmq-otel";

const worker = new Worker(
  "myQueue",
  async (job) => {
    return 'some value'
  },
  {
    name: "myWorker",
    connection: {
      host: "127.0.0.1",
      port: 6379,
    },
    telemetry: new BullMQOtel("simple-guide"),
  }
);
```

--------------------------------

### Run Tests with Yarn

Source: https://github.com/taskforcesh/bullmq/blob/master/contributing.md

This command sequence installs project dependencies and runs all defined test cases. Ensure you have Yarn installed and the project dependencies are up to date before executing.

```shell
yarn
yarn test
```

--------------------------------

### Install BullMQ using Yarn

Source: https://github.com/taskforcesh/bullmq/blob/master/README.md

This snippet shows how to add BullMQ to your project dependencies using the Yarn package manager. This is the initial step before utilizing BullMQ's features.

```bash
$ yarn add bullmq
```

--------------------------------

### Import and Use BullMQ Pro Classes

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/install.md

This TypeScript code snippet shows how to import and instantiate the Pro versions of Queue and Worker from BullMQ Pro. These classes extend the base BullMQ library with additional features.

```typescript
import { QueuePro, WorkerPro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue');

const worker = new WorkerPro('myQueue', async job => {
  // Process job
});
```

--------------------------------

### Listen for queue progress events with timestamp in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

This snippet demonstrates how to listen for job progress events emitted by `QueueEvents`, including the timestamp of the event. It requires a `QueueEvents` instance. The input is progress events with data, and the output is a console log showing the job ID, progress data, and event timestamp.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents("my-queue-name");

queueEvents.on('progress', ({ jobId, data }, timestamp) => {
  console.log(`${jobId} reported progress ${data} at ${timestamp}`);
});
```

--------------------------------

### Process jobs with a BullMQ worker in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

This code demonstrates how to create a BullMQ worker that listens to a queue and processes incoming jobs. It requires a connection to Redis and defines a job processing function. The input is the job data from the queue, and the output is the result of the job processing logic (e.g., console logging).

```typescript
import { Worker } from 'bullmq';
import IORedis from 'ioredis';

const connection = new IORedis({ maxRetriesPerRequest: null });

const worker = new Worker(
  'foo',
  async job => {
    // Will print { foo: 'bar'} for the first job
    // and { qux: 'baz' } for the second.
    console.log(job.data);
  },
  { connection },
);

```

--------------------------------

### Install BullMQ Python Package

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/python/introduction.md

This command installs the BullMQ Python package using pip. It's the standard way to add the library to your Python environment.

```bash
$ pip install bullmq
```

--------------------------------

### Basic Job Processing with BullMQ in JavaScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Demonstrates how to create BullMQ queues, define job processors using callbacks, handle job progress and completion/errors, and add jobs to the queue. Supports multiple queue types for different tasks.

```javascript
const Queue = require("bull");

const videoQueue = new Queue("video transcoding", "redis://127.0.0.1:6379");
const audioQueue = new Queue("audio transcoding", {
  redis: { port: 6379, host: "127.0.0.1", password: "foobared" },
}); // Specify Redis connection using object
const imageQueue = new Queue("image transcoding");
const pdfQueue = new Queue("pdf transcoding");

videoQueue.process(function (job, done) {
  // job.data contains the custom data passed when the job was created
  // job.id contains id of this job.

  // transcode video asynchronously and report progress
  job.progress(42);

  // call done when finished
  done();

  // or give a error if error
  done(new Error("error transcoding"));

  // or pass it a result
  done(null, { framerate: 29.5 /* etc... */ });

  // If the job throws an unhandled exception it is also handled correctly
  throw new Error("some unexpected error");
});

audioQueue.process(function (job, done) {
  // transcode audio asynchronously and report progress
  job.progress(42);

  // call done when finished
  done();

  // or give a error if error
  done(new Error("error transcoding"));

  // or pass it a result
  done(null, { samplerate: 48000 /* etc... */ });

  // If the job throws an unhandled exception it is also handled correctly
  throw new Error("some unexpected error");
});

imageQueue.process(function (job, done) {
  // transcode image asynchronously and report progress
  job.progress(42);

  // call done when finished
  done();

  // or give a error if error
  done(new Error("error transcoding"));

  // or pass it a result
  done(null, { width: 1280, height: 720 /* etc... */ });

  // If the job throws an unhandled exception it is also handled correctly
  throw new Error("some unexpected error");
});

pdfQueue.process(function (job) {
  // Processors can also return promises instead of using the done callback
  return pdfAsyncProcessor();
});

videoQueue.add({ video: "http://example.com/video1.mov" });
audioQueue.add({ audio: "http://example.com/audio1.mp3" });
imageQueue.add({ image: "http://example.com/image1.tiff" });

```

--------------------------------

### BullMQ Cluster Support for Parallel Job Processing

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

This example demonstrates using Node.js 'cluster' module with BullMQ to distribute jobs across multiple worker processes. It sets up a master process to fork workers and a queue to add jobs, while worker processes consume and process these jobs concurrently.

```javascript
const Queue = require("bull");
const cluster = require("cluster");

const numWorkers = 8;
const queue = new Queue("test concurrent queue");

if (cluster.isMaster) {
  for (let i = 0; i < numWorkers; i++) {
    cluster.fork();
  }

  cluster.on("online", function (worker) {
    // Let's create a few jobs for the queue workers
    for (let i = 0; i < 500; i++) {
      queue.add({ foo: "bar" });
    }
  });

  cluster.on("exit", function (worker, code, signal) {
    console.log("worker " + worker.process.pid + " died");
  });
} else {
  queue.process(function (job, jobDone) {
    console.log("Job done by worker", cluster.worker.id, job.id);
    jobDone();
  });
}
```

--------------------------------

### Monitor queue events with QueueEvents in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

This code illustrates how to use `QueueEvents` to listen for various events across all workers for a specific queue, such as waiting, active, completed, and failed jobs. It requires initializing a `QueueEvents` instance. The input is queue-related events, and the output is console logs detailing the event and associated job information.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents("my-queue-name");

queueEvents.on('waiting', ({ jobId }) => {
  console.log(`A job with ID ${jobId} is waiting`);
});

queueEvents.on('active', ({ jobId, prev }) => {
  console.log(`Job ${jobId} is now active; previous status was ${prev}`);
});

queueEvents.on('completed', ({ jobId, returnvalue }) => {
  console.log(`${jobId} has completed and returned ${returnvalue}`);
});

queueEvents.on('failed', ({ jobId, failedReason }) => {
  console.log(`${jobId} has failed with reason ${failedReason}`);
});
```

--------------------------------

### Launch BullMQ Services with OpenTelemetry (Node.js)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

Launches BullMQ producer and consumer services using the Node.js runtime with OpenTelemetry instrumentation. This method is suitable for JavaScript projects or after compiling TypeScript to JavaScript.

```shell
node --import producer.inst.otlp.js producer.js
node --import consumer.inst.otlp.js consumer.js
```

--------------------------------

### Install BullMQ Python Package

Source: https://github.com/taskforcesh/bullmq/blob/master/python/README.md

Installs the BullMQ Python library using pip. This is the primary step to integrate BullMQ functionality into your Python project.

```bash
pip install bullmq
```

--------------------------------

### Add .npmrc to Dockerfile for BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/install.md

This Dockerfile snippet demonstrates how to copy the .npmrc configuration file into the Docker image. This ensures that Docker builds can correctly authenticate with the private NPM registry to install BullMQ Pro.

```docker
WORKDIR /app

ADD .npmrc /app/.npmrc
```

--------------------------------

### BullMQ Consumer Job Processing Logs

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

Example console output from a BullMQ consumer service launched with OpenTelemetry instrumentation. These logs show the processing of individual jobs and are generated by custom logs within the worker's 'process' function.

```log
> tsx --import consumer.inst.otlp.ts consumer.ts

processing job 1 0
processing job 2 0
processing job 3 0
processing job 4 0
processing job 5 0
processing job 6 0
...
processing job 43 1
processing job 44 1
processing job 45 1
processing job 46 1
processing job 47 1
processing job 48 1
processing job 49 1
processing job 50 1
```

--------------------------------

### Add Repeatable Job Examples

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Demonstrates how to add repeatable jobs with different repetition patterns using cron expressions or fixed intervals.

```APIDOC
## Adding Repeatable Jobs

Repeatable jobs can be added using the `add` method with the `repeat` option. This option can specify a cron `pattern` or a fixed `every` interval in milliseconds.

### Method
POST

### Endpoint
/api/queues/:queueName/jobs

### Parameters
#### Query Parameters
- **queueName** (string) - Required - The name of the queue.

#### Request Body
- **name** (string) - Required - The name of the job.
- **data** (object) - Optional - The data payload for the job.
- **opts** (object) - Optional - Job options, including the `repeat` object.
  - **repeat** (object) - Optional - Configuration for job repetition.
    - **pattern** (string) - Optional - A cron expression string (e.g., '0 15 3 * * *').
    - **every** (number) - Optional - The interval in milliseconds between job repetitions (e.g., 10000 for 10 seconds).
    - **limit** (number) - Optional - The maximum number of times the job should repeat.

### Request Example (Cron Pattern)
```json
{
  "name": "submarine",
  "data": {"color": "yellow"},
  "opts": {
    "repeat": {
      "pattern": "0 15 3 * * *"
    }
  }
}
```

### Request Example (Fixed Interval)
```json
{
  "name": "bird",
  "data": {"color": "bird"},
  "opts": {
    "repeat": {
      "every": 10000,
      "limit": 100
    }
  }
}
```

### Response
#### Success Response (200)
- **id** (string) - The ID of the added job.
- **repeatJobKey** (string) - The unique key for the repeatable job configuration.

#### Response Example
```json
{
  "id": "job_id_123",
  "repeatJobKey": "repeatable_job_key_abc"
}
```
```

--------------------------------

### Configure NPM Registry for BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/install.md

This configuration snippet is used to set up your project's .npmrc file to use the private NPM registry for BullMQ Pro. It requires an environment variable NPM_TASKFORCESH_TOKEN to authenticate.

```npmrc
@taskforcesh:registry=https://npm.taskforce.sh/
//npm.taskforce.sh/:_authToken=${NPM_TASKFORCESH_TOKEN}
always-auth=true
```

--------------------------------

### Install NestJS BullMQ Pro Module

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Install the @taskforcesh/nestjs-bullmq-pro package using yarn. This package provides the necessary modules for integrating BullMQ Pro with NestJS.

```bash
yarn add @taskforcesh/nestjs-bullmq-pro
```

--------------------------------

### Get Jobs

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/getters.md

Retrieves jobs from a queue with pagination. You can specify the desired job statuses, the starting index, the limit, and whether to fetch the oldest jobs first.

```APIDOC
## GET /jobs

### Description
Retrieves jobs from a queue with pagination. You can specify the desired job statuses, the starting index, the limit, and whether to fetch the oldest jobs first.

### Method
GET

### Endpoint
`/jobs`

### Query Parameters
- **status** (string[]) - Required - An array of job statuses to retrieve.
- **start** (number) - Required - The starting index for pagination.
- **end** (number) - Required - The ending index for pagination (limit).
- **asc** (boolean) - Optional - If true, fetches the oldest jobs first. Defaults to false.

### Response
#### Success Response (200)
- **jobs** (array) - An array of job objects matching the specified criteria.

### Response Example
```json
[
  {
    "id": "job_id_1",
    "name": "job_name",
    "status": "completed",
    "data": {},
    "opts": {},
    "returnvalue": null,
    "error": null,
    "attemptsMade": 0,
    "progress": 0,
    "delay": 0,
    "timestamp": 1678886400000,
    "processedOn": 1678886460000,
    "finishedOn": 1678886520000
  }
]
```
```

--------------------------------

### Starting Jaeger Service with Docker Compose

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-jaeger.md

Command to initiate the Docker Compose services defined in the docker-compose.yaml file. This command pulls the necessary images and starts the Jaeger container, making it accessible via its UI.

```bash
docker-compose up
```

--------------------------------

### Create BullMQ Producer with Telemetry (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

This snippet shows how to create a BullMQ producer that adds jobs in bulk. It includes the BullMQOtel integration for telemetry, allowing spans to be linked between producers and consumers. Requires 'bullmq' and 'bullmq-otel' packages.

```typescript
import { Queue } from "bullmq";
import { BullMQOtel } from "bullmq-otel";

const queue = new Queue("myQueue", {
  connection: {
    host: "127.0.0.1",
    port: 6379,
  },
  telemetry: new BullMQOtel("simple-guide"),
});

const jobsBulk = Array.from({ length: 5 }, (_, i) => i);

(async () => {
  for (let i = 0; i < 10; i++) {
    await queue.addBulk(
      jobsBulk.map((j) => ({
        name: `myJob ${j}`,
        data: { i: j },
        opts: { attempts: 2, backoff: 1000 },
      }))
    );
  }
})();
```

--------------------------------

### Configuring Sandboxed Processes for BullMQ Jobs (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Illustrates how to configure BullMQ to run job processors in separate, sandboxed processes. This enhances stability, allows for blocking code, and improves CPU utilization.

```javascript
// processor.js
module.exports = function (job) {
  // Do some heavy work

  return Promise.resolve(result);
}

```

```javascript
// Single process:
queue.process('/path/to/my/processor.js');

// You can use concurrency as well:
queue.process(5, '/path/to/my/processor.js');

// and named processors:
queue.process('my processor', 5, '/path/to/my/processor.js');

```

--------------------------------

### IORedis Retry Strategy for BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/going-to-production.md

Defines a custom retry strategy for IORedis connections used by BullMQ. This strategy employs exponential backoff, with retries starting at 1 second and capping at 20 seconds, to manage disconnections gracefully.

```typescript
retryStrategy: function (times: number) {
    return Math.max(Math.min(Math.exp(times), 20000), 1000);
 }
```

--------------------------------

### Get Full Job Flow Tree with BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/get-flow-tree.md

Retrieves a job and its entire hierarchical structure of children, grandchildren, etc., using the getFlow method. This example demonstrates adding a parent job with multiple levels of children and then fetching the complete flow tree.

```typescript
const flow = new FlowProducer({ connection });

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name, 
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      children: [
        {
          name,
          data: { idx: 4, foo: 'baz' },
          queueName: 'grandchildrenQueueName',
        },
      ],
    },
    {
      name,
      data: { idx: 2, foo: 'foo' },
      queueName: 'childrenQueueName',
    },
    {
      name,
      data: { idx: 3, foo: 'bis' },
      queueName: 'childrenQueueName',
    },
  ],
});

const { job: topJob } = originalTree;

const tree = await flow.getFlow({
  id: topJob.id,
  queueName: 'topQueueName',
});

const { children, job } = tree;
```

--------------------------------

### Install NestJS BullMQ Module

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/README.md

Installs the `@nestjs/bullmq` package using npm. This is the first step to enable BullMQ functionality within a NestJS project.

```bash
npm i @nestjs/bullmq
```

--------------------------------

### Launch BullMQ Services with OpenTelemetry (TSX)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

Launches BullMQ producer and consumer services using tsx, ensuring OpenTelemetry instrumentation is applied first. This is crucial for capturing all tracing data, even though BullMQ itself may not patch other modules.

```shell
tsx --import producer.inst.otlp.ts producer.ts
tsx --import consumer.inst.otlp.ts consumer.ts
```

--------------------------------

### Create and Add Job to BullMQ Queue (Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/python/README.md

Demonstrates how to create a BullMQ queue instance and add a job with data to it. This requires the BullMQ Python library to be installed and an event loop to handle asynchronous operations.

```python
from bullmq import Queue

queue = Queue('my-queue')

job = await queue.add('my-job', {'foo': 'bar'})
```

--------------------------------

### Listen for worker events (completed/failed) in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/README (1).md

This snippet shows how to attach event listeners to a BullMQ worker to react to job completion or failure. It requires a pre-initialized worker instance. The input is job completion or failure events, and the output is console logs indicating the job status.

```typescript
worker.on('completed', job => {
  console.log(`${job.id} has completed!`);
});

worker.on('failed', (job, err) => {
  console.log(`${job.id} has failed with ${err.message}`);
});
```

--------------------------------

### Using Promises for Job Processing in BullMQ (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Shows an alternative way to define BullMQ job processors by returning promises instead of using the `done` callback. This approach simplifies asynchronous operations and error handling with promises.

```javascript
videoQueue.process(function (job) {
  // don't forget to remove the done callback!
  // Simply return a promise
  return fetchVideo(job.data.url).then(transcodeVideo);

  // Handles promise rejection
  return Promise.reject(new Error("error transcoding"));

  // Passes the value the promise is resolved with to the "completed" event
  return Promise.resolve({ framerate: 29.5 /* etc... */ });

  // If the job throws an unhandled exception it is also handled correctly
  throw new Error("some unexpected error");
  // same as
  return Promise.reject(new Error("some unexpected error"));
});

```

--------------------------------

### Remove Repeatable Job Examples

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Illustrates how to remove repeatable jobs using their keys or by specifying the job name and repeat options.

```APIDOC
## Removing Repeatable Jobs

Repeatable jobs can be removed either by their unique `repeatJobKey` or by providing the job name and its specific repeat options.

### Method
DELETE

### Endpoint
- `/api/queues/:queueName/repeatable-jobs/:repeatJobKey` (by key)
- `/api/queues/:queueName/repeatable-jobs` (by name and options)

### Parameters
#### Path Parameters
- **queueName** (string) - Required - The name of the queue.
- **repeatJobKey** (string) - Required (for key-based removal) - The unique key of the repeatable job.

#### Request Body (for name and options removal)
- **name** (string) - Required - The name of the job to remove.
- **repeat** (object) - Required - The repeat options that match the job to be removed.
  - **pattern** (string) - Optional - The cron pattern used for repetition.
  - **every** (number) - Optional - The interval in milliseconds used for repetition.

### Request Example (Remove by Key)
```json
{} 
```
*(No request body is needed when removing by `repeatJobKey`)*

### Request Example (Remove by Name and Options)
```json
{
  "name": "blue",
  "repeat": {
    "pattern": "*/1 * * * * *"
  }
}
```

### Response
#### Success Response (200)
- **removed** (boolean) - Indicates whether the repeatable job was successfully removed.

#### Response Example
```json
{
  "removed": true
}
```
```

--------------------------------

### Create BullMQ Consumer with Telemetry (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-a-simple-example.md

This snippet defines a BullMQ consumer that processes jobs concurrently and simulates failures for retry demonstration. It integrates BullMQOtel for telemetry, enabling the visualization of job failures, retries, and completion through spans. Requires 'bullmq' and 'bullmq-otel' packages.

```typescript
import { Worker } from "bullmq";
import { BullMQOtel } from "bullmq-otel";

(async () => {
  const worker = new Worker(
    "myQueue",
    async (job) => {
      console.log("processing job", job.id, job.attemptsMade);
      await new Promise(async (res) => {
        setTimeout(() => res({}), 200);
      });

      if (job.attemptsMade < 1) {
        throw new Error("This was an error");
      }

      return "my result value";
    },
    {
      name: "myWorker",
      connection: {
        host: "127.0.0.1",
        port: 6379,
      },
      telemetry: new BullMQOtel("simple-guide"),
      concurrency: 10,
    }
  );
})();
```

--------------------------------

### Create Multiple Queues in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

This snippet shows how to create multiple named queues in BullMQ. Each queue instance requires a new Redis connection. Consider reusing connections or using named processors for efficiency.

```javascript
const userJohn = new Queue('john');
const userLisa = new Queue('lisa');
.
.
.
```

--------------------------------

### Get Job Schedulers List in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/manage-job-schedulers.md

The `getJobSchedulers` method retrieves a list of all configured job schedulers within a specified range. It can be used to monitor and manage multiple schedulers, especially in dynamic scheduling environments. The example shows retrieving the first 10 schedulers.

```typescript
const schedulers = await queue.getJobSchedulers(0, 9, true);
console.log('Current job schedulers:', schedulers);
```

--------------------------------

### Get Jobs with Pagination in TypeScript and Python

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/getters.md

Retrieve jobs from a BullMQ queue with pagination. This method allows fetching a specific range of jobs based on their status. It takes an array of statuses, start and end offsets for pagination, and a boolean to determine the order (oldest first if true).

```typescript
const completed = await myQueue.getJobs(['completed'], 0, 100, true);

// returns the oldest 100 jobs
```

```python
completed = await myQueue.getJobs(['completed'], 0, 100, True)

# returns the oldest 100 jobs
```

--------------------------------

### Get Repeatable Jobs

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Retrieves a list of all currently configured repeatable jobs in the specified queue.

```APIDOC
## Get Repeatable Jobs

This endpoint retrieves all repeatable job configurations currently present in the queue.

### Method
GET

### Endpoint
/api/queues/:queueName/repeatable-jobs

### Parameters
#### Path Parameters
- **queueName** (string) - Required - The name of the queue.

### Request Example
```json
{} 
```
*(No request body is needed for GET requests)*

### Response
#### Success Response (200)
- **repeatableJobs** (array) - An array of repeatable job objects.
  - Each object contains details about a repeatable job, such as its name, data, repeat options, and `repeatJobKey`.

#### Response Example
```json
{
  "repeatableJobs": [
    {
      "key": "repeatable_job_key_abc",
      "name": "submarine",
      "data": {"color": "yellow"},
      "opts": {
        "repeat": {
          "pattern": "0 15 3 * * *"
        }
      }
    },
    {
      "key": "repeatable_job_key_xyz",
      "name": "bird",
      "data": {"color": "bird"},
      "opts": {
        "repeat": {
          "every": 10000,
          "limit": 100
        }
      }
    }
  ]
}
```
```

--------------------------------

### Pausing and Resuming BullMQ Queues (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/quick-guide.md

Shows how to globally pause and resume a BullMQ queue to temporarily stop job processing. The `pause` and `resume` methods return promises that resolve when the operation is complete.

```javascript
queue.pause().then(function () {
  // queue is paused now
});

queue.resume().then(function () {
  // queue is resumed now
});

```

--------------------------------

### Handling Unhandled Exceptions and Rejections in Node.js

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/going-to-production.md

This code illustrates how to handle uncaught exceptions and unhandled promise rejections in a Node.js application. Implementing these handlers prevents the application from crashing due to unexpected errors, allowing for graceful error logging and management.

```typescript
process.on("uncaughtException", function (err) {
  // Handle the error safely
  logger.error(err, "Uncaught exception");
});

process.on("unhandledRejection", (reason, promise) => {
  // Handle the error safely
  logger.error({ promise, reason }, "Unhandled Rejection at: Promise");
});

```

--------------------------------

### BullMQ Worker Setup (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/stalled.md

This snippet demonstrates how to set up a BullMQ worker in TypeScript. It imports the Worker class and initializes a new worker instance for the 'Paint' queue, associating it with a handler function named 'painter'.

```typescript
import { Worker } from 'bullmq';

const worker = new Worker('Paint', painter);
```

--------------------------------

### Define Multiple Custom Backoff Types in BullMQ Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This example shows how to implement a BullMQ worker capable of handling multiple named custom backoff strategies. The `backoffStrategy` function uses a switch statement to differentiate between types like 'custom1' and 'custom2', applying different retry delays based on the specified type. This provides a robust way to manage various custom retry logics within a single worker setup.

```typescript
import { Worker } from 'bullmq';

const worker = new Worker('foo', async job => doSomeProcessing(), {
  settings: {
    backoffStrategy: (
      attemptsMade: number,
      type: string,
      err: Error,
      job: Job,
    ) => {
      switch (type) {
        case 'custom1': {
          return attemptsMade * 1000;
        }
        case 'custom2': {
          return attemptsMade * 2000;
        }
        default: {
          throw new Error('invalid type');
        }
      }
    },
  },
});

```

--------------------------------

### Add Jobs to a BullMQ Queue (Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/python/introduction.md

Demonstrates how to add jobs to a BullMQ queue using the Python package. It requires an active Redis connection and specifies the queue name, job name, and job data. The example uses asyncio for asynchronous operations.

```python
from bullmq import Queue

queue = Queue("myQueue")

# Add a job with data { "foo": "bar" } to the queue
await queue.add("myJob", { "foo": "bar" })

...

# Close when done adding jobs
await queue.close()
```

--------------------------------

### Control Worker Execution with `autorun: false` (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Shows how to instantiate a BullMQ Worker with the `autorun: false` option, preventing immediate execution of the processor. The `worker.run()` method must then be called explicitly to start processing. Dependencies include 'bullmq'.

```typescript
import { Worker, Job } from 'bullmq';

const worker = new Worker(
  queueName,
  async (job: Job) => {
    // Optionally report some progress
    await job.updateProgress(42);

    // Optionally sending an object as progress
    await job.updateProgress({ foo: 'bar' });

    // Do something with job
    return 'some value';
  },
  { autorun: false },
);

worker.run();
```

--------------------------------

### Manual Rate-Limit Job Fail with Attempt Check in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/stop-retrying-jobs.md

This example shows how to manually handle rate-limited jobs in BullMQ and prevent retries by checking `job.attemptsStarted` against `job.opts.attempts`. If the job is rate-limited and has already started the maximum number of attempts, it throws an `UnrecoverableError`. Otherwise, it throws `RateLimitError` to signal a temporary issue that requires waiting, not retrying.

```typescript
import { Worker, RateLimitError, UnrecoverableError } from 'bullmq';

const worker = new Worker(
  'myQueue',
  async job => {
    const [isRateLimited, duration] = await doExternalCall();
    if (isRateLimited) {
      await queue.rateLimit(duration);
      if (job.attemptsStarted >= job.opts.attempts) {
        throw new UnrecoverableError('Unrecoverable');
      }
      // Do not forget to throw this special exception,
      // since we must differentiate this case from a failure
      // in order to move the job to wait again.
      throw new RateLimitError();
    }
  },
  {
    connection,
    limiter: {
      max: 1,
      duration: 500,
    },
  },
);
```

--------------------------------

### Listen for Job Completion Event (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Provides an example of how to listen for the 'completed' event on a BullMQ worker. This allows you to access the return value of a successfully processed job. Dependencies include 'bullmq'.

```typescript
worker.on('completed', (job: Job, returnvalue: any) => {
  // Do something with the return value.
});
```

--------------------------------

### BullMQ Worker Error Handling

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/going-to-production.md

Attaches an error event listener to a BullMQ Worker instance. This is crucial for logging connection issues and preventing unhandled errors, contributing to system robustness.

```typescript
worker.on("error", (err) => {
  // Log your error.
})
```

--------------------------------

### Listen to Aggregated Queue Events with QueueEvents (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/README.md

This example illustrates using BullMQ's QueueEvents class in TypeScript to listen for 'completed' and 'progress' events from all workers processing a specific queue. It leverages Redis streams for reliable event delivery and requires the 'bullmq' package.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents('Paint');

queueEvents.on('completed', ({ jobId }: { jobId: string }) => {
  // Called every time a job is completed in any worker.
  console.log(`Job ${jobId} completed across all workers.`);
});

queueEvents.on(
  'progress',
  ({ jobId, data }: { jobId: string; data: number | object }) => {
    // jobId received a progress event
    console.log(`Job ${jobId} progress: ${JSON.stringify(data)}`);
  },
);
```

--------------------------------

### Export Prometheus Metrics with Global Variables (Node.js)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/metrics/prometheus.md

Demonstrates advanced usage of BullMQ's Prometheus exporter by including global variables as labels. This enables adding context like environment or server ID to metrics, useful for aggregation. The example uses vanilla Node.js.

```typescript
import http from 'http';
import { Queue } from 'bullmq';

const queue = new Queue('my-queue');

const server = http.createServer(
  async (req: http.IncomingMessage, res: http.ServerResponse) => {
    try {
      if (req.url === '/metrics' && req.method === 'GET') {
        const globalVariables = { env: 'Production', server: '1' };
        const metrics = await queue.exportPrometheusMetrics(globalVariables);

        res.writeHead(200, {
          'Content-Type': 'text/plain',
          'Content-Length': Buffer.byteLength(metrics),
        });
        res.end(metrics);
      } else {
        res.writeHead(404);
        res.end('Not Found');
      }
    } catch (err: unknown) {
      res.writeHead(500);
      res.end(`Error: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  },
);

const PORT = process.env.PORT || 3000;

server.listen(PORT, () => {
  console.log(`Prometheus metrics server running on port ${PORT}`);
  console.log(`Metrics available at http://localhost:${PORT}/metrics`);
});
```

--------------------------------

### BullMQ Queue Error Handling

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/going-to-production.md

Attaches an error event listener to a BullMQ Queue instance. This handler is essential for monitoring connection problems and ensuring that errors are logged, which aids in debugging and maintaining queue stability.

```typescript
queue.on("error", (err) => {
  // Log your error.
})
```

--------------------------------

### Start Stalled Jobs Checker in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

This code snippet shows how to manually start the stalled jobs checker in BullMQ. This checker periodically runs to identify and move jobs whose locks have expired back to the 'wait' status, or to 'failed' if they have exhausted their retry attempts.

```typescript
await worker.startStalledCheckTimer()
```

--------------------------------

### Graceful Worker Shutdown with SIGINT and SIGTERM

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/going-to-production.md

This snippet demonstrates how to gracefully shut down BullMQ workers by listening for SIGINT and SIGTERM signals in a Node.js environment. It ensures that active jobs are closed before the process exits, minimizing the risk of stalled jobs. This is crucial for server restarts.

```typescript
const gracefulShutdown = async (signal) => {
  console.log(`Received ${signal}, closing server...`);
  await worker.close();
  // Other asynchronous closings
  process.exit(0);
}

process.on('SIGINT', () => gracefulShutdown('SIGINT'));

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

```

--------------------------------

### Get Group Jobs API

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Retrieves a paginated list of jobs within a specific group.

```APIDOC
## GET /groups/{groupId}/jobs

### Description
Retrieves a list of jobs belonging to a specific group, with support for pagination.

### Method
GET

### Endpoint
`/groups/{groupId}/jobs`

### Parameters
#### Path Parameters
- **groupId** (string) - Required - The ID of the group from which to retrieve jobs.

#### Query Parameters
- **offset** (number) - Required - The starting index for retrieving jobs (e.g., 0 for the first job).
- **limit** (number) - Required - The maximum number of jobs to return.

### Request Example
```json
{
  "example": "// No request body for this endpoint. Example usage is in the code snippet.\nimport { QueuePro } from '@taskforcesh/bullmq-pro';\n\nconst queue = new QueuePro('myQueue', { connection });\nconst groupId = 'my group';\nconst jobs = await queue.getGroupJobs(groupId, 0, 100); // Get first 100 jobs"
}
```

### Response
#### Success Response (200)
- **jobs** (array) - An array of job objects.
  - **id** (string) - The job ID.
  - **name** (string) - The job name.
  - **status** (string) - The current status of the job (e.g., 'active', 'completed', 'failed').
  - **data** (object) - The data associated with the job.

#### Response Example
```json
{
  "example": "{\n  \"jobs\": [\n    {\n      \"id\": \"job123\",\n      \"name\": \"process_data\",\n      \"status\": \"completed\",\n      \"data\": { \"userId\": 1 }\n    },\n    {\n      \"id\": \"job456\",\n      \"name\": \"send_email\",\n      \"status\": \"active\",\n      \"data\": { \"email\": \"test@example.com\" }\n    }\n  ]\n}"
}
```
```

--------------------------------

### Docker Compose for Jaeger All-in-One

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/telemetry/running-jaeger.md

This Docker Compose configuration sets up the Jaeger all-in-one image, exposing necessary ports for trace export (4318) and the UI (16686). It's a straightforward way to get Jaeger running for monitoring distributed systems like BullMQ with OpenTelemetry.

```yaml
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: BullMQ_with_opentelemetry_jaeger
    ports:
      - '4318:4318'
      - '16686:16686'
```

--------------------------------

### Set Job Scheduler to Start Later with startDate

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-options.md

Configures a job scheduler to begin repeating from a specific future date. This is useful for scheduling recurring tasks that should not commence until a designated time. The job will only be scheduled after the `startDate` has been reached.

```typescript
const { Queue } = require('bullmq');
const connection = { host: 'localhost', port: 6379 };
const myQueue = new Queue('my-dated-jobs', { connection });

await myQueue.upsertJobScheduler(
  'start-later-job',
  {
    every: 60000, // every minute
    startDate: new Date('2024-10-15T00:00:00Z'), // start on October 15, 2024
  },
  {
    name: 'timed-start-job',
    data: { message: 'Starting later' },
  },
);
```

--------------------------------

### Listen for Worker Job Failure Events (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers.md

Provides an example of how to catch and handle job failures by listening to the 'failed' event on a BullMQ worker. This is crucial for error handling, logging, and potential retry mechanisms. Dependencies include 'bullmq'.

```typescript
worker.on('failed', (job: Job, error: Error) => {
  // Do something with the return value.
});
```

--------------------------------

### Get Job Counts

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/getters.md

Retrieves the number of jobs in specified statuses within a queue. Available statuses include 'completed', 'failed', 'delayed', 'active', 'wait', 'waiting-children', 'prioritized', 'paused', and 'repeat'.

```APIDOC
## GET /jobs/counts

### Description
Retrieves the number of jobs in specified statuses within a queue.

### Method
GET

### Endpoint
`/jobs/counts`

### Query Parameters
- **status** (string[]) - Required - An array of job statuses to count.

### Response
#### Success Response (200)
- **counts** (object) - An object where keys are job statuses and values are the counts for each status.

### Response Example
```json
{
  "wait": 5,
  "completed": 10,
  "failed": 2
}
```
```

--------------------------------

### Get Group Active Count API

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Retrieves the count of active jobs for a specific group.

```APIDOC
## GET /groups/{groupId}/active/count

### Description
Retrieves the number of currently active jobs within a specified group.

### Method
GET

### Endpoint
`/groups/{groupId}/active/count`

### Parameters
#### Path Parameters
- **groupId** (string) - Required - The ID of the group for which to retrieve the active job count.

### Request Example
```json
{
  "example": "// No request body for this endpoint. Example usage is in the code snippet.\nimport { QueuePro } from '@taskforcesh/bullmq-pro';\n\nconst queue = new QueuePro('myQueue', { connection });\nconst groupId = 'my group';\nconst activeCount = await queue.getGroupActiveCount(groupId);"
}
```

### Response
#### Success Response (200)
- **activeJobCount** (number) - The count of active jobs in the specified group.

#### Response Example
```json
{
  "example": "{\n  \"activeJobCount\": 50\n}"
}
```
```

--------------------------------

### Get Specific Job Scheduler in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/manage-job-schedulers.md

The `getJobScheduler` method retrieves a single job scheduler by its ID. This is useful for inspecting the configuration of a specific scheduled task.

```typescript
const scheduler = await queue.getJobScheduler('test');
console.log('Current job scheduler:', scheduler);
```

--------------------------------

### Get Groups Jobs Count API

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Retrieves the count of jobs within groups. This count includes both prioritized and non-prioritized jobs.

```APIDOC
## GET /groups/jobs/count

### Description
Retrieves the total number of jobs across specified groups. The `count` parameter determines how many groups are processed in each iteration.

### Method
GET

### Endpoint
`/groups/jobs/count`

### Parameters
#### Query Parameters
- **count** (number) - Required - The number of groups to process in each iteration.

### Request Example
```json
{
  "example": "// No request body for this endpoint. Example usage is in the code snippet.\nimport { QueuePro } from '@taskforcesh/bullmq-pro';\n\nconst queue = new QueuePro('myQueue', { connection });\nconst totalJobCount = await queue.getGroupsJobsCount(1000); // 1000 groups in each iteration"
}
```

### Response
#### Success Response (200)
- **jobCount** (number) - The total count of jobs in the specified groups.

#### Response Example
```json
{
  "example": "{\n  \"jobCount\": 15000\n}"
}
```
```

--------------------------------

### Registering BullMQ Queue and Events Listener in NestJS Module

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/queue-events-listeners.md

This code demonstrates how to configure a NestJS module to use BullMQ. It registers a queue named 'queueName' with specified connection details using `BullModule.registerQueue`. Additionally, it registers the `TestQueueEvents` class, created in the previous example, as a provider within the `AppModule`, making the queue event listener available to the application.

```typescript
@Module({
  imports: [
    BullModule.registerQueue({
      name: 'queueName',
      connection: {
        host: '0.0.0.0',
        port: 6380,
      },
    }),
  ],
  providers: [TestQueueEvents],
})
export class AppModule {}
```

--------------------------------

### Get Job State in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Fetches the current state of a job. This includes standard states and a 'waiting-children' state for parent jobs awaiting child job completion.

```typescript
const state = await job.getState();
// state will be "waiting-children"
```

--------------------------------

### Get Direct Job Dependencies

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Demonstrates how to retrieve the direct dependencies (children) of a given job using the `getDependencies` method on the `Job` class. This method returns an array of jobs that are direct children.

```typescript
const dependencies = await job.getDependencies();

```

--------------------------------

### Get Children Values for Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Retrieves all values produced by the children of a given job. This functionality helps in aggregating results from child jobs within a flow.

```typescript
const values = await job.getChildrenValues();
```

--------------------------------

### Get Paginated Job Dependencies

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Shows how to retrieve paginated lists of job dependencies (children) based on their status (processed, unprocessed, failed, ignored) using the `getDependencies` method with pagination options. This allows for efficient retrieval of large sets of dependencies.

```typescript
// cursors are used in pagination
const { processed, nextProcessedCursor } = await job.getDependencies({
  processed: {
    count: 5,
    cursor: 0,
  },
});

const { unprocessed, nextUnprocessedCursor } = await job.getDependencies({
  unprocessed: {
    count: 5,
    cursor: 0,
  },
});

const { failed, nextFailedCursor } = await job.getDependencies({
  failed: {
    count: 5,
    cursor: 0,
  },
});

const { ignored, nextIgnoredCursor } = await job.getDependencies({
  ignored: {
    count: 5,
    cursor: 0,
  },
});

```

--------------------------------

### Get Rate Limit TTL for BullMQ Queue

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/rate-limiting.md

Retrieves the Time-To-Live (TTL) for the rate limit on a BullMQ queue. This helps determine if the queue is currently rate-limited by checking if the returned TTL is greater than 0.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('myQueue', { connection });
const maxJobs = 100;

const ttl = await queue.getRateLimitTtl(maxJobs);

if (ttl > 0) {
  console.log('Queue is rate limited');
}
```

--------------------------------

### Instantiate BullMQ Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/README.md

Demonstrates how to create a new Queue instance in BullMQ. This is the foundational step for managing jobs. Ensure Redis connection details are configured as per BullMQ's connection documentation.

```typescript
const queue = new Queue('Cars');
```

--------------------------------

### Get Job Counts by Priority in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/prioritized.md

Explains how to obtain the number of jobs within specific priority levels in a BullMQ queue. This includes counting jobs with assigned priorities (non-zero) and those in the waiting state (priority zero).

```typescript
const counts = await queue.getCountsPerPriority([1, 0]);
/*
{
  '1': 11,
  '0': 10
}
*/
```

--------------------------------

### Loop Through Jobs for Continuous Processing in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

This example illustrates an infinite loop designed for continuously processing jobs one by one in BullMQ. It fetches jobs using `worker.getNextJob`, processes them, and then moves them to completed or failed states. The logic handles re-instantiating the `Job` object for subsequent iterations.

```typescript
const worker = new Worker('my-queue');

const token = 'my-token';
let job;

while (1) {
  let jobData = null,
    jobId,
    success;

  if (job) {
    // Use job.data to process this particular job.
    // and set success variable if succeeded

    if (success) {
      [jobData, jobId] = await job.moveToCompleted('some return value', token);
    } else {
      await job.moveToFailed(new Error('some error message'), token);
    }

    if (jobData) {
      job = Job.fromJSON(worker, jobData, jobId);
    } else {
      job = null;
    }
  } else {
    if (!job) {
      job = await worker.getNextJob(token);
    }
  }
}
```

--------------------------------

### Configure Exponential Backoff with Delay and Jitter in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This example demonstrates configuring the 'exponential' backoff strategy in BullMQ with both a delay and a jitter option. Jitter introduces randomness to the retry delay, creating a delay between a calculated maximum and a randomized minimum. This helps to further distribute retries and avoid thundering herd problems. The snippet sets 8 attempts, a base delay of 3000ms, and a jitter of 0.5.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 8,
    backoff: {
      type: 'exponential',
      delay: 3000,
      jitter: 0.5,
    },
  },
);

```

--------------------------------

### Query BullMQ Queue Metrics

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/metrics/README.md

Retrieves performance metrics for a BullMQ queue, specifically for completed or failed jobs within a given time frame. It requires importing `Queue` from 'bullmq' and uses the `getMetrics` method, optionally specifying the job type, start, and end points. The method returns an object containing job counts and time-series data.

```typescript
import { Queue } from 'bullmq';
const myQueue = new Queue('Paint', {
  connection,
});

const metrics = await queue.getMetrics('completed', 0, MetricsTime.ONE_WEEK * 2);

/* Returns a Metrics object:
{
    data: number[];
    count: number;
    meta: {
      count: number;
      prevTS: number;
      prevCount: number;
    };
  }
*/
```

--------------------------------

### Connect BullMQ Worker to AWS MemoryDB Cluster

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/redis-tm-hosting/aws-memorydb.md

Demonstrates how to establish a connection to an AWS MemoryDB cluster using IORedis and configure a BullMQ worker to use this connection. Ensure IORedis is installed as a dependency. The input is the connection details for the MemoryDB cluster, and the output is a configured BullMQ worker ready to process jobs.

```typescript
import { Cluster } from 'ioredis';
import { Worker } from 'bullmq';

const connection = new Cluster(
  [
    {
      host: 'clustercfg.xxx.amazonaws.com',
      port: 6379,
    },
  ],
  {
    tls: {},
  },
);

const worker = new Worker(
  'myqueue',
  async (job: Job) => {
    // Do some usefull stuff
  },
  { connection },
);

// ...

// Do not forget to close the connection as well as the worker when shutting down
await worker.close();
await connection.quit();
```

--------------------------------

### Add Job Data in BullMQ (TypeScript & Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/job-data.md

Demonstrates how to add custom data to a new job when adding it to a BullMQ queue. The data is stored in the 'data' attribute of the job object. This example uses TypeScript and Python.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('paint');

const job = await myQueue.add('wall', { color: 'red' });

job.data; // { color: 'red' }
```

```python
from bullmq import Queue

queue = Queue('paint')

job = await queue.add('wall', {'color': 'red'})

job.data # { color: 'red' }
```

--------------------------------

### Get Dependency Counts for Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Retrieves counts of job dependencies categorized by their status (failed, ignored, processed, unprocessed). This function can fetch all counts at once or specific counts by passing boolean flags.

```typescript
const { failed, ignored, processed, unprocessed } =
  await job.getDependenciesCount();
```

```typescript
const { failed } = await job.getDependenciesCount({
  failed: true,
});

const { ignored, processed } = await job.getDependenciesCount({
  ignored: true,
  processed: true,
});

const { unprocessed } = await job.getDependenciesCount({
  unprocessed: true,
});
```

--------------------------------

### Get BullMQ Global Concurrency (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/global-concurrency.md

Retrieves the current global concurrency limit configured for a BullMQ queue. This value dictates the maximum number of jobs that can be processed concurrently across all active worker instances.

```typescript
import { Queue } from 'bullmq';

const globalConcurrency = await queue.getGlobalConcurrency();
```

--------------------------------

### Get BullMQ Active Jobs Count for a Group (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Fetches the number of currently active jobs within a specific group in BullMQ. This method is useful for monitoring the workload of a particular group.

```typescript
const activeCount = await queue.getGroupActiveCount(groupId);
```

--------------------------------

### Remove Deduplication Key in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

This example illustrates how to remove a deduplication key before its time-to-live (ttl) expires or before a job completes, using the `removeDeduplicationKey` method of a BullMQ Queue instance. It accepts the deduplication key as an argument and is an asynchronous operation.

```typescript
await myQueue.removeDeduplicationKey('customValue');

```

--------------------------------

### BullMQ Fixed Backoff with Jitter Retry

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

Sets up a BullMQ job for automatic retries with a fixed delay and jitter. The 'jitter' option introduces a random delay within a specified range, calculated as a percentage of the base 'delay', to prevent thundering herd issues. This example uses TypeScript.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 8,
    backoff: {
      type: 'fixed',
      delay: 1000,
      jitter: 0.5,
    },
  },
);
```

--------------------------------

### Get Group Rate Limit TTL - TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/rate-limiting.md

Retrieves the Time-To-Live (TTL) for a group's rate limit. This method helps determine if a group is currently rate-limited by checking if the returned TTL is greater than 0.

```typescript
import { QueuePro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue', { connection });
const groupId = '0';
const maxJobs = 100;

const ttl = await queue.getGroupRateLimitTtl(groupId, maxJobs);

if (ttl > 0) {
  console.log('Group is rate limited');
}
```

--------------------------------

### Throttle Jobs using Job IDs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/throttle-jobs.md

This TypeScript example demonstrates how to add jobs to a BullMQ queue with a specified `jobId`. When multiple jobs with the same `jobId` are added, BullMQ only queues the first one, effectively throttling subsequent identical job requests. This prevents the queue from being flooded with redundant tasks.

```typescript
import { Job, Queue, Worker } from 'bullmq';

const myQueue = new Queue('Paint');

const worker = new Worker('Paint', async (job: Job) => {
  console.log('Do something with job');
  return 'some value';
});

worker.on('completed', (job: Job, returnvalue: any) => {
  console.log('worker done painting', new Date());
});

worker.on('failed', (job: Job, error: Error) => {
  console.error('worker fail painting', job, error, new Date());
});

// Add only one job that will be delayed at least 1 second.
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
myQueue.add('house', { color: 'white' }, { delay: 1000, jobId: 'house' });
```

--------------------------------

### BullMQ Fixed Backoff Retry

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

Configures a BullMQ job to retry automatically with a fixed delay. The 'attempts' option specifies the maximum number of retries, and the 'backoff' setting with 'type: "fixed"' and 'delay' defines the retry interval in milliseconds. This example uses TypeScript.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 3,
    backoff: {
      type: 'fixed',
      delay: 1000,
    },
  },
);
```

--------------------------------

### Get BullMQ Global Rate Limit TTL (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/global-rate-limit.md

Retrieves the time-to-live (TTL) value associated with the global rate limit set on a BullMQ queue. This helps in understanding how long the current rate limit configuration is active or relevant. It returns a number representing the TTL in milliseconds.

```typescript
const globalConcurrency = await queue.getRateLimitTtl();
```

--------------------------------

### Update Job Data in BullMQ (TypeScript & Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/job-data.md

Illustrates how to modify the data of an existing job using the 'updateData' method in BullMQ. This allows for dynamic changes to job payloads after they have been initially added. Examples are provided for TypeScript and Python.

```typescript
const job = await Job.create(queue, 'wall', { color: 'red' });

await job.updateData({
  color: 'blue',
});

job.data; // { color: 'blue' }
```

```python
from bullmq import Queue

queue = Queue('paint')

job = await queue.add('wall', {'color': 'red'})

await job.updateData({'color': 'blue'})
job.data # { color: 'blue' }
```

--------------------------------

### Get BullMQ Grouped Job Counts (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Retrieves the total number of jobs across multiple groups in BullMQ. This count includes both prioritized and non-prioritized jobs within the groups. The method iterates through groups in chunks of a specified size.

```typescript
import { QueuePro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue', { connection });
const groupId = 'my group';
const count = await queue.getGroupsJobsCount(1000); // 1000 groups in each iteration
```

--------------------------------

### Get Job Counts per Priority for a Group in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/prioritized.md

Retrieves the counts of jobs for specified priorities within a given group. This method is part of BullMQ Pro and allows detailed status checking for prioritized and waiting jobs.

```typescript
const counts = await queue.getCountsPerPriorityForGroup('groupId', [1, 0]);
/*
{
  '1': 11,
  '0': 10
}
*/
```

--------------------------------

### BullMQ Parent Job Processing Logic with Child Failure Handling

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/continue-parent.md

This example demonstrates how to define a parent job that reacts differently based on child job outcomes. It uses `continueParentOnFailure` to allow the parent to proceed if a child fails, `getFailedChildrenValues` to identify failures, and `removeUnprocessedChildren` to clean up remaining child jobs. This is useful for workflows where a child failure requires immediate parent intervention or cancellation of other tasks.

```typescript
const { FlowProducer } = require('bullmq');
const flow = new FlowProducer({ connection });

// Define the flow
const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name: 'child-job-1',
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      opts: { continueParentOnFailure: true }, // Parent processes if this child fails
    },
    {
      name: 'child-job-2',
      data: { idx: 1, foo: 'baz' },
      queueName: 'childrenQueueName',
    },
    {
      name: 'child-job-3',
      data: { idx: 2, foo: 'qux' },
      queueName: 'childrenQueueName',
    },
  ],
});

// Processor for the parent job
const processor = async (job) => {
  // Check if any children failed
  const failedChildren = await job.getFailedChildrenValues();
  const hasFailedChildren = Object.keys(failedChildren).length > 0;

  if (hasFailedChildren) {
    // Path 1: A child failed, triggering continueParentOnFailure
    console.log(`Parent job ${job.name} triggered by child failure(s):`, failedChildren);
    
    // Remove unprocessed children
    await job.removeUnprocessedChildren();
    console.log('Unprocessed child jobs have been removed.');
    
    // Additional cleanup or error handling can go here
  } else {
    // Path 2: All children completed successfully
    console.log(`Parent job ${job.name} processing after all children completed successfully.`);
    
    // Proceed with normal parent logic (e.g., aggregating results)
  }
};

```

--------------------------------

### Get Local Group Concurrency in BullMQ Pro (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/local-group-concurrency.md

Retrieves the configured concurrency value for a specific job group from BullMQ Pro. This is used to check the currently set concurrency limit for a group. Requires the `QueuePro` class.

```typescript
const concurrency = await queue.getGroupConcurrency(groupId);
```

--------------------------------

### Get Job Counts in TypeScript and Python

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/getters.md

Retrieve the number of jobs in specified statuses from a BullMQ queue. This method takes an array of status strings as input and returns an object containing the counts for each status. It's useful for monitoring queue health and job distribution.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

const counts = await myQueue.getJobCounts('wait', 'completed', 'failed');

// Returns an object like this { wait: number, completed: number, failed: number }
```

```python
from bullmq import Queue

myQueue = Queue('Paint')

counts = await myQueue.getJobCounts('wait', 'completed', 'failed')

# Returns an object like this { wait: number, completed: number, failed: number }
```

--------------------------------

### Initialize Worker with Sandboxed Processor URL (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/sandboxed-processors.md

Initializes a BullMQ Worker using a processor defined via a URL instance. This approach is recommended for Windows OS. Requires the 'url' module for pathToFileURL.

```typescript
import { pathToFileURL } from 'url';

const processorUrl = pathToFileURL(__dirname + '/my_procesor.js');

worker = new Worker(queueName, processorUrl);
```

--------------------------------

### Get Deduplication Job ID in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

This code snippet shows how to retrieve the job ID that initiated a deduplicated state using the `getDeduplicationJobId` method of a BullMQ Queue instance. It takes a deduplication ID as input and returns the associated job ID. This function is asynchronous.

```typescript
const jobId = await myQueue.getDeduplicationJobId('customValue');

```

--------------------------------

### Configure Worker Lock Duration in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

This code shows how to configure the `lockDuration` option when creating a BullMQ worker. The `lockDuration` sets the maximum time a job will be locked, preventing other workers from processing it. This example sets the lock duration to 60 seconds (60000 milliseconds).

```typescript
const worker = new Worker('my-queue', null, { lockDuration: 60000 });
```

--------------------------------

### Enable Telemetry for BullMQ Pro Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/telemetry.md

Initializes a BullMQ Pro queue with OpenTelemetry integration using the BullMQ-Otel library. This allows for tracking of queue operations. It requires the `@taskforcesh/bullmq-pro` and `bullmq-otel` packages.

```typescript
import { QueuePro } from '@taskforcesh/bullmq-pro';
import { BullMQOtel } from 'bullmq-otel';

// Initialize a Pro queue using BullMQ-Otel
const queue = new QueuePro('myProQueue', {
  connection,
  telemetry: new BullMQOtel('guide'),
});

await queue.add(
  'myJob',
  { data: 'myData' },
  {
    attempts: 2,
    backoff: 1000,
    group: {
      id: 'myGroupId',
    },
  },
);
```

--------------------------------

### Limit Job Flow Tree Depth and Children with BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/get-flow-tree.md

Retrieves a job and its flow tree but limits the results by depth and the maximum number of children per node. This is useful for managing large job hierarchies and reducing data transfer. It uses the `depth` and `maxChildren` options.

```typescript
const limitedTree = await flow.getFlow({
  id: topJob.id,
  queueName: 'topQueueName',
  depth: 1, 
  maxChildren: 2, 
});

const { children, job } = limitedTree;
```

--------------------------------

### Define a Custom Backoff Strategy in BullMQ Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This TypeScript example shows how to define a custom backoff strategy for a BullMQ worker. The `backoffStrategy` function is provided in the worker's settings and determines the delay between retries. This function receives the number of attempts made and can implement any logic, such as a linear backoff (attempts * 1000ms). A return value of 0 moves the job to the end of the waiting list, while -1 fails the job.

```typescript
import { Worker } from 'bullmq';

const worker = new Worker('foo', async job => doSomeProcessing(), {
  settings: {
    backoffStrategy: (attemptsMade: number) => {
      return attemptsMade * 1000;
    },
  },
});

```

--------------------------------

### Instantiate BullMQ Worker and Process Jobs (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Demonstrates how to create a BullMQ Worker instance and define an asynchronous job processing function. The processor can optionally report progress and return a value upon completion. Dependencies include 'bullmq'.

```typescript
import { Worker, Job } from 'bullmq';

const worker = new Worker(queueName, async (job: Job) => {
  // Optionally report some progress
  await job.updateProgress(42);

  // Optionally sending an object as progress
  await job.updateProgress({ foo: 'bar' });

  // Do something with job
  return 'some value';
});
```

--------------------------------

### Instantiate BullMQ Queue with Default Job Options

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/fifo.md

Shows how to instantiate a BullMQ queue with default job options. This sets common configurations, such as automatic removal of completed jobs and retention of a specific number of failed jobs, for all subsequent jobs added to this queue. Requires the 'bullmq' library.

```typescript
const queue = new Queue('Paint', { defaultJobOptions: {
  removeOnComplete: true, removeOnFail: 1000
});
```

--------------------------------

### Timeout Fetch Call with AbortController in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/timeout-jobs.md

This example shows how to timeout a `fetch` call within a BullMQ worker using TypeScript. A `setTimeout` is configured to abort an `AbortController`, which is passed to the `fetch` options as its `signal`. If the fetch operation or subsequent `response.text()` call is aborted due to the timeout, an `UnrecoverableError` is thrown. The timeout timer is cleared in the `finally` block.

```typescript
const worker = new Worker("foo", async (job) => { 
  let controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), job.data.timeout);
  try {
    let response = await fetch("/slowserver.com", {
      signal: controller.signal,
    }); 
    const result = await response.text();
  } catch (err) {
    if (err.name == "AbortError") {
      throw new UnrecoverableError("Timeout");
    } else {
      throw err;
    }
  } finally {
    clearTimeout(timer)
  }
});
```

--------------------------------

### Set Local Concurrency Factor in BullMQ Worker (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/concurrency.md

Configures a BullMQ worker to process multiple jobs concurrently by setting the 'concurrency' option during initialization. This is suitable for I/O-bound operations where Node.js can handle parallel asynchronous tasks efficiently. The concurrency level can be adjusted dynamically after the worker has started.

```typescript
import { Worker, Job } from 'bullmq';

const worker = new Worker(
  queueName,
  async (job: Job) => {
    // Do something with job
    return 'some value';
  },
  { concurrency: 50 },
);

worker.concurrency = 5;

```

--------------------------------

### Process Jobs in BullMQ Workers (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/README.md

Illustrates how to set up a worker to process jobs from a queue. The worker listens for specific job names and executes corresponding logic, such as painting a car based on provided data.

```typescript
import { Worker } from 'bullmq';

const worker = new Worker('Paint', async job => {
  if (job.name === 'cars') {
    await paintCar(job.data.color);
  }
});
```

--------------------------------

### Enable Telemetry for BullMQ Pro Worker (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/telemetry.md

Sets up a BullMQ Pro worker with OpenTelemetry integration using the BullMQ-Otel library. This enables telemetry for job processing. It requires the `@taskforcesh/bullmq-pro` and `bullmq-otel` packages.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';
import { BullMQOtel } from 'bullmq-otel';

const worker = new WorkerPro(
  'myProQueue',
  async job => {
    console.log('processing job', job.id);
  },
  {
    name: 'myWorker',
    connection,
    telemetry: new BullMQOtel('guide'),
    concurrency: 10,
    batch: { size: 10 },
  },
);
```

--------------------------------

### Listen for Global Queue Events (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Demonstrates how to use `QueueEvents` to listen for global job completion, failure, and progress events across all workers for a specific queue. Dependencies include 'bullmq'.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents('Paint');

queueEvents.on('completed', ({ jobId: string, returnvalue: any }) => {
  // Called every time a job is completed by any worker.
});

queueEvents.on('failed', ({ jobId: string, failedReason: string }) => {
  // Called whenever a job is moved to failed by any worker.
});

queueEvents.on('progress', ({jobId: string, data: number | object}) => {
  // jobId received a progress event
});
```

--------------------------------

### Instantiate BullMQ Worker and Process Jobs (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers.md

Demonstrates how to create a BullMQ worker instance and define an asynchronous function to process incoming jobs. The processor function can return a value upon successful completion. Dependencies include 'bullmq'.

```typescript
import { Worker, Job } from 'bullmq';

const worker = new Worker(queueName, async (job: Job) => {
  // Do something with job
  return 'some value';
});
```

--------------------------------

### Listen to Queue Events in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/README.md

This snippet demonstrates how to listen for 'waiting' events on a BullMQ Queue instance in TypeScript. It requires the 'bullmq' package and a running Redis instance.

```typescript
import { Queue, Job } from 'bullmq';

const myQueue = new Queue('Paint');

myQueue.on('waiting', (job: Job) => {
  // Job is waiting to be processed.
  console.log(`Job ${job.id} is waiting.`);
});
```

--------------------------------

### Initialize Worker with Sandboxed Processor Path (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/sandboxed-processors.md

Initializes a BullMQ Worker using a processor defined in a separate file. The 'processorFile' variable holds the path to the sandboxed processor. Requires the 'path' module.

```typescript
import { Worker } from 'bullmq'

const processorFile = path.join(__dirname, 'my_procesor.js');
worker = new Worker(queueName, processorFile);
```

--------------------------------

### Create Job Scheduler with Cron Pattern and Template

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/README.md

Illustrates creating a Job Scheduler using a cron pattern ('0 15 3 * * *' for 3:15 AM daily) and defining a job template. The template includes a job name, data, and specific options like backoff, attempts, and removeOnFail. This showcases the flexibility of `upsertJobScheduler` for complex scheduling and job configuration.

```typescript
const firstJob = await queue.upsertJobScheduler(
  'my-scheduler-id',
  { pattern: '0 15 3 * * *' },
  {
    name: 'my-job-name',
    data: { foo: 'bar' },
    opts: {
      backoff: 3,
      attempts: 5,
      removeOnFail: 1000,
    },
  },
);
```

--------------------------------

### Initialize and Close QueueScheduler in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queuescheduler.md

Demonstrates how to instantiate the QueueScheduler for a given queue and how to properly close it during graceful shutdown. This is essential for managing delayed and stalled jobs.

```typescript
import { QueueScheduler } from 'bullmq';

const queueScheduler = new QueueScheduler('test');

// Later, when shuting down gracefully
await queueScheduler.close();
```

--------------------------------

### Instantiate BullMQ Worker with a Sandboxed Processor (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers.md

Illustrates how to configure a BullMQ worker to use a sandboxed processor defined in a separate file. This approach enhances isolation for job execution. Requires the path to the processor file. Dependencies include 'bullmq' and 'path'.

```typescript
const processorFile = path.join(__dirname, 'my_procesor.js');
worker = new Worker(queueName, processorFile);
```

--------------------------------

### Listen for Job Completion and Failure Events (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/README.md

Shows how to use `QueueEvents` to listen for job lifecycle events like 'completed' and 'failed'. This allows for real-time monitoring and handling of job outcomes, including logging success or failure reasons.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents('Paint');

queueEvents.on('completed', ({ jobId }) => {
  console.log('done painting');
});

queueEvents.on(
  'failed',
  ({ jobId, failedReason }: { jobId: string; failedReason: string }) => {
    console.error('error painting', failedReason);
  }
);
```

--------------------------------

### Create New Redis Connections for Queue and Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/connections.md

Demonstrates creating separate Redis connections for a BullMQ Queue and Worker instance by passing connection options directly. This approach is suitable when each instance requires its own independent connection to Redis.

```typescript
import { Queue, Worker } from 'bullmq';

// Create a new connection in every instance
const myQueue = new Queue('myqueue', {
  connection: {
    host: 'myredis.taskforce.run',
    port: 32856,
  },
});

const myWorker = new Worker('myqueue', async job => {}, {
  connection: {
    host: 'myredis.taskforce.run',
    port: 32856,
  },
});
```

--------------------------------

### Export Prometheus Metrics with Vanilla Node.js

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/metrics/prometheus.md

Exposes BullMQ queue metrics via an HTTP endpoint using vanilla Node.js. This snippet creates a basic HTTP server that responds to '/metrics' requests by fetching and returning Prometheus-formatted metrics from a BullMQ queue. It handles basic error responses.

```typescript
import http from 'http';
import { Queue } from 'bullmq';

const queue = new Queue('my-queue');

const server = http.createServer(
  async (req: http.IncomingMessage, res: http.ServerResponse) => {
    try {
      if (req.url === '/metrics' && req.method === 'GET') {
        const metrics = await queue.exportPrometheusMetrics();

        res.writeHead(200, {
          'Content-Type': 'text/plain',
          'Content-Length': Buffer.byteLength(metrics),
        });
        res.end(metrics);
      } else {
        res.writeHead(404);
        res.end('Not Found');
      }
    } catch (err: unknown) {
      res.writeHead(500);
      res.end(`Error: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  },
);

const PORT = process.env.PORT || 3000;

server.listen(PORT, () => {
  console.log(`Prometheus metrics server running on port ${PORT}`);
  console.log(`Metrics available at http://localhost:${PORT}/metrics`);
});
```

--------------------------------

### Add Jobs to a BullMQ Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/README.md

Demonstrates how to create a new queue and add jobs to it. Jobs are defined with a name and associated data. This is a fundamental operation for dispatching tasks.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('Paint');

queue.add('cars', { color: 'blue' });
```

--------------------------------

### Add Repeatable Jobs with BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Demonstrates how to add repeatable jobs to a BullMQ queue using either a cron pattern or a fixed repetition interval with a limit. It requires importing Queue and QueueScheduler. The 'repeat' option within the job configuration specifies the repetition logic.

```typescript
import { Queue, QueueScheduler } from 'bullmq';

const myQueueScheduler = new QueueScheduler('Paint');
const myQueue = new Queue('Paint');

// Repeat job once every day at 3:15 (am)
await myQueue.add(
  'submarine',
  { color: 'yellow' },
  {
    repeat: {
      pattern: '0 15 3 * * *',
    },
  },
);

// Repeat job every 10 seconds but no more than 100 times
await myQueue.add(
  'bird',
  { color: 'bird' },
  {
    repeat: {
      every: 10000,
      limit: 100,
    },
  },
);
```

--------------------------------

### Custom Repeatable Key for Jobs

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Demonstrates how to use a custom 'key' within the 'repeat' options in BullMQ to uniquely identify and manage repeatable jobs. This is useful for updating job settings by providing a new job with the same key.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint', { connection });

// Repeat job every 10 seconds
await myQueue.add(
  'bird',
  { color: 'gray' },
  {
    repeat: {
      every: 10_000,
      key: 'colibri',
    },
  },
);

// Repeat job every 10 seconds
await myQueue.add(
  'bird',
  { color: 'brown' },
  {
    repeat: {
      every: 10_000,
      key: 'eagle',
    },
  },
);

// Repeat job every 25 seconds instead of 10 seconds
await myQueue.add(
  'bird',
  { color: 'turquoise' },
  {
    repeat: {
      every: 25_000,
      key: 'eagle',
    },
  },
);
```

--------------------------------

### Enable BullMQ Worker Metrics

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/metrics/README.md

Enables the metrics gathering functionality on a BullMQ worker. This setting determines how many data points (1-minute intervals) the worker will store, allowing for performance tracking over a specified duration. It requires importing `Worker` and `MetricsTime` from 'bullmq'.

```typescript
import { Worker, MetricsTime } from 'bullmq';

const myWorker = new Worker('Paint', {
  connection,
  metrics: {
    maxDataPoints: MetricsTime.ONE_WEEK * 2,
  },
});
```

--------------------------------

### Define a Sandboxed Processor for BullMQ Worker (JavaScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers.md

Shows how to define a job processing function in a separate file, intended to be run as a sandboxed processor by BullMQ. This isolates the job logic and is referenced by its file path when creating the worker. Dependencies include 'bullmq'.

```javascript
import { Job } from 'bullmq';

module.exports = async (job: Job) => {
    // Do something with job
};
```

--------------------------------

### Listen for Global BullMQ Queue Events (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers.md

Demonstrates how to use `QueueEvents` to listen for global 'completed', 'failed', and 'progress' events across all workers associated with a specific queue. This enables centralized monitoring and reaction to job lifecycle changes. Dependencies include 'bullmq'.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents('Paint');

queueEvents.on('completed', ({ jobId: string, returnvalue: any }) => {
  // Called every time a job is completed in any worker.
});

queueEvents.on('failed', ({ jobId: string, failedReason: string }) => {
  // jobId received a progress event
});

queueEvents.on('progress', ({jobId: string, data: number | object}) => {
  // jobId received a progress event
});
```

--------------------------------

### Schedule Jobs Every 10 Seconds with BullMQ 'every' Strategy (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-strategies.md

This snippet demonstrates how to use the 'every' strategy in BullMQ to schedule a job that repeats every 10 seconds. It requires the 'bullmq' package and a Redis connection. The code defines a queue, upserts a repeatable job with a 10000ms interval, and sets up a worker to process these jobs.

```typescript
const { Queue, Worker } = require('bullmq');

const connection = {
  host: 'localhost',
  port: 6379,
};

const myQueue = new Queue('my-repeatable-jobs', { connection });

// Upserting a repeatable job in the queue
await myQueue.upsertJobScheduler(
  'repeat-every-10s',
  {
    every: 10000, // Job will repeat every 10000 milliseconds (10 seconds)
  },
  {
    name: 'every-job',
    data: { jobData: 'data' },
    opts: {}, // Optional additional job options
  },
);

// Worker to process the jobs
const worker = new Worker(
  'my-repeatable-jobs',
  async job => {
    console.log(`Processing job ${job.id} with data: ${job.data.jobData}`);
  },
  { connection },
);
```

--------------------------------

### Configure BullMQ Pro in AppModule

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Configure the BullMQ Pro module in your root AppModule by importing BullModule.forRoot and providing the Redis connection details. This establishes the connection for all subsequent queue and producer registrations.

```typescript
import {
  Module
} from '@nestjs/common';
import {
  BullModule
} from '@taskforcesh/nestjs-bullmq-pro';

@Module({
  imports: [
    BullModule.forRoot({
      connection: {
        host: 'localhost',
        port: 6379,
      },
    }),
  ],
})
export class AppModule {}
```

--------------------------------

### Specify Job and Return Types with Generics (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Shows how to use TypeScript generics with the BullMQ Worker class to define specific types for job data and the expected return value, improving type safety. Dependencies include 'bullmq'.

```typescript
const worker = new Worker<MyData, MyReturn>(queueName, async (job: Job) => {});
```

--------------------------------

### Create Job Scheduler with Fixed Interval

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/README.md

Demonstrates how to create a new Job Scheduler that generates a job every 1000 milliseconds (1 second). The method returns the first job created, which will be in a 'delayed' status. This utilizes the `upsertJobScheduler` method with an `every` option.

```typescript
const firstJob = await queue.upsertJobScheduler('my-scheduler-id', {
  every: 1000,
});
```

--------------------------------

### Add FIFO Job to BullMQ Queue

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/fifo.md

Demonstrates how to add a basic FIFO job to a BullMQ queue. This job will be processed in the order it was added. It requires the 'bullmq' library.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

// Add a job that will be processed after all others
await myQueue.add('wall', { color: 'pink' });
```

--------------------------------

### Manage Waiting Children with moveToWaitingChildren (Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/process-step-jobs.md

Illustrates the use of `moveToWaitingChildren` in Python for managing parent jobs that create child jobs. This implementation includes state transitions, adding child jobs, and employing `WaitingChildrenError` for proper job flow control. Requires BullMQ-Python and a connection object.

```python
from bullmq import Worker, WaitingChildrenError
from enum import Enum

class Step(int, Enum):
  Initial = 1
  Second = 2
  Third = 3
  Finish = 4

async def process(job: Job, token: str):
  step = job.data.get("step")
  while step != Step.Finish:
    if step == Step.Initial:
      await doInitialStepStuff()
      await children_queue.add('child-1', {"foo": "bar" },{
        "parent": {
            "id": job.id,
            "queue": job.queueQualifiedName
        }
      })
      await job.updateData({
          "step": Step.Second
      })
      step = Step.Second
    elif step == Step.Second:
      await doSecondStepStuff()
      await children_queue.add('child-2', {"foo": "bar" },{
        "parent": {
          "id": job.id,
          "queue": job.queueQualifiedName
        }
      })
      await job.updateData({
          "step": Step.Third
      })
      step = Step.Third
    elif step == Step.Third:
      should_wait = await job.moveToWaitingChildren(token, {{}})
      if not should_wait:
        await job.updateData({
            "step": Step.Finish
        })
        step = Step.Finish
        return Step.Finish
      else:
        raise WaitingChildrenError
    else:
      raise Exception("invalid step")

worker = Worker("parentQueueName", process, {"connection": connection})

```

--------------------------------

### Schedule Jobs with Cron Expressions using BullMQ 'cron' Strategy (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-strategies.md

This snippet illustrates how to use BullMQ's 'cron' strategy with cron expressions for precise job scheduling. It leverages the 'cron-parser' library. The code shows setting up a queue, upserting a job with a cron pattern to run every weekday at 9:00 AM, and a worker to handle these jobs.

```typescript
const { Queue, Worker } = require('bullmq');

const connection = {
  host: 'localhost',
  port: 6379,
};

const myQueue = new Queue('my-cron-jobs', { connection });

// Upserting a job with a cron expression
await myQueue.upsertJobScheduler(
  'weekday-morning-job',
  {
    pattern: '0 0 9 * * 1-5', // Runs at 9:00 AM every Monday to Friday
  },
  {
    name: 'cron-job',
    data: { jobData: 'morning data' },
    opts: {}, // Optional additional job options
  },
);

// Worker to process the jobs
const worker = new Worker(
  'my-cron-jobs',
  async job => {
    console.log(
      `Processing job ${job.id} at ${new Date()} with data: ${ 
        job.data.jobData 
      }`,
    );
  },
  { connection },
);
```

--------------------------------

### Force Immediate Job Execution with immediately (Deprecated)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-options.md

Ensures that the first instance of a job created by a scheduler runs immediately upon addition, overriding the regular interval alignment. This is particularly useful for long intervals where a delay until the next scheduled time is undesirable. Note: This option is deprecated from version 5.19.0 onwards, with new behavior defaulting to immediate first execution.

```typescript
await myQueue.upsertJobScheduler(
  'immediate-job',
  {
    every: 86400000, // once a day
    immediately: true, // execute the first one immediately
  },
  {
    name: 'instant-job',
    data: { message: 'Immediate start' },
  },
);
```

--------------------------------

### Adding a Flow to BullMQ in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/producers.md

Demonstrates how to initiate a job flow using the injected Flow Producer's `add()` method. This method allows defining a root job and its subsequent child jobs, specifying queue names and data for each.

```typescript
const job = await this.fooFlowProducer.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name,
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
    },
  ],
});
```

--------------------------------

### Manage Waiting Children with moveToWaitingChildren (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/process-step-jobs.md

Demonstrates how to use `moveToWaitingChildren` in TypeScript to manage jobs that spawn child jobs. It handles job updates, child job addition, and signals completion or waiting states using `WaitingChildrenError`. Requires BullMQ and a connection object.

```typescript
import { WaitingChildrenError, Worker } from 'bullmq';

enum Step {
  Initial,
  Second,
  Third,
  Finish,
}

const worker = new Worker(
  'parentQueueName',
  async (job: Job, token?: string) => {
    let step = job.data.step;
    while (step !== Step.Finish) {
      switch (step) {
        case Step.Initial: {
          await doInitialStepStuff();
          await childrenQueue.add(
            'child-1',
            { foo: 'bar' },
            {
              parent: {
                id: job.id,
                queue: job.queueQualifiedName,
              },
            },
          );
          await job.updateData({
            step: Step.Second,
          });
          step = Step.Second;
          break;
        }
        case Step.Second: {
          await doSecondStepStuff();
          await childrenQueue.add(
            'child-2',
            { foo: 'bar' },
            {
              parent: {
                id: job.id,
                queue: job.queueQualifiedName,
              },
            },
          );
          await job.updateData({
            step: Step.Third,
          });
          step = Step.Third;
          break;
        }
        case Step.Third: {
          const shouldWait = await job.moveToWaitingChildren(token);
          if (!shouldWait) {
            await job.updateData({
              step: Step.Finish,
            });
            step = Step.Finish;
            return Step.Finish;
          } else {
            throw new WaitingChildrenError();
          }
        }
        default: {
          throw new Error('invalid step');
        }
      }
    }
  },
  { connection },
);

```

--------------------------------

### Publish and Subscribe to Custom Events in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/create-custom-events.md

This snippet demonstrates how to set up a custom event emitter in BullMQ. It shows the usage of QueueEventsProducer to publish events and QueueEvents to subscribe to them. Consumers define interfaces for event payloads and listeners, while the producer publishes events with a specified event name and custom payload. Ensure the 'eventName' attribute is always provided.

```typescript
const queueName = 'customQueue';
const queueEventsProducer = new QueueEventsProducer(queueName, {
  connection,
});
const queueEvents = new QueueEvents(queueName, {
  connection,
});

interface CustomListener extends QueueEventsListener {
  example: (args: { custom: string }, id: string) => void;
}
queueEvents.on<CustomListener>('example', async ({ custom }) => {
  // custom logic
});

interface CustomEventPayload {
  eventName: string;
  custom: string;
}

await queueEventsProducer.publishEvent<CustomEventPayload>({
  eventName: 'example',
  custom: 'value',
});
```

--------------------------------

### Reuse ioredis Instance for Multiple Queues

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/connections.md

Shows how to create a single ioredis instance and reuse it across multiple BullMQ Queue instances. This is efficient for managing multiple producers that can share the same Redis connection.

```typescript
import { Queue } from 'bullmq';
import IORedis from 'ioredis';

const connection = new IORedis();

// Reuse the ioredis instance in 2 different producers
const myFirstQueue = new Queue('myFirstQueue', { connection });
const mySecondQueue = new Queue('mySecondQueue', { connection });
```

--------------------------------

### Define Sandboxed Processor File (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/sandboxed-processors.md

Defines an asynchronous function to process jobs within a sandboxed environment. This file's path is passed to the Worker constructor. It requires the 'bullmq' library for the SandboxedJob type.

```typescript
import { SandboxedJob } from 'bullmq';

module.exports = async (job: SandboxedJob) => {
    // Do something with job
};
```

--------------------------------

### Retrieve Repeatable Jobs with BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Illustrates how to retrieve all currently configured repeatable jobs from a BullMQ queue. This function returns an array of repeatable job objects. It requires importing the Queue class.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

const repeatableJobs = await myQueue.getRepeatableJobs();
```

--------------------------------

### Export Prometheus Metrics with Express.js

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/metrics/prometheus.md

Provides a simpler way to expose BullMQ queue metrics using Express.js. This snippet defines an Express route '/metrics' that fetches and sends Prometheus-formatted metrics. It's suitable for projects already using Express.

```typescript
import express from 'express';
import { Queue } from './src/queue';

const app = express();
const queue = new Queue('my-queue');

app.get('/metrics', async (req, res) => {
  try {
    const metrics = await queue.exportPrometheusMetrics();
    res.set('Content-Type', 'text/plain');
    res.send(metrics);
  } catch (err) {
    res.status(500).send(err.message);
  }
});

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Prometheus metrics server running on port ${PORT}`);
  console.log(`Metrics available at http://localhost:${PORT}/metrics`);
});
```

--------------------------------

### Custom Repeat Strategy with RRULE

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Defines a custom repeat strategy for BullMQ using the 'rrule' library. This function calculates the next occurrence based on RRULE patterns and handles options like startDate and count. It requires 'bullmq' and 'rrule' as dependencies.

```typescript
import { Queue, QueueScheduler, Worker } from 'bullmq';
import { rrulestr } from 'rrule';

const settings = {
  repeatStrategy: (millis, opts) => {
    const currentDate = 
      opts.startDate && new Date(opts.startDate) > new Date(millis) 
        ? new Date(opts.startDate) 
        : new Date(millis);
    const rrule = rrulestr(opts.pattern);
    if (rrule.origOptions.count && !rrule.origOptions.dtstart) {
      throw new Error('DTSTART must be defined to use COUNT with rrule');
    }

    const next_occurrence = rrule.after(currentDate, false);
    return next_occurrence?.getTime();
  },
};

const myQueueScheduler = new QueueScheduler('Paint');
const myQueue = new Queue('Paint', { settings });

// Repeat job every 10 seconds
await myQueue.add(
  'bird',
  { color: 'green' },
  {
    repeat: {
      pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=;WKST=MO',
    },
    jobId: 'colibri',
  },
);

await myQueue.add(
  'bird',
  { color: 'gray' },
  {
    repeat: {
      pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=;WKST=MO',
    },
    jobId: 'pigeon',
  },
);

const worker = new Worker(
  'Paint',
  async () => {
    doSomething();
  },
  { settings },
);
```

--------------------------------

### Reuse Redis Connections with createClient in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/reusing-redis-connections.md

This TypeScript code demonstrates how to reuse Redis connections for BullMQ queues using the `createClient` option. It configures separate clients for 'client', 'subscriber', and 'bclient' types, essential for environments with limited Redis connections. Dependencies include 'ioredis' and BullMQ's 'Queue'.

```typescript
const { REDIS_URL } = process.env;

const Redis = require("ioredis");
const client = new Redis(REDIS_URL);
const subscriber = new Redis(REDIS_URL);

const opts = {
  // redisOpts here will contain at least a property of
  // connectionName which will identify the queue based on its name
  createClient: function (type, redisOpts) {
    switch (type) {
      case "client":
        return client;
      case "subscriber":
        return subscriber;
      case "bclient":
        return new Redis(REDIS_URL, redisOpts);
      default:
        throw new Error("Unexpected connection type: ", type);
    }
  },
};

const queueFoo = new Queue("foobar", opts);
const queueQux = new Queue("quxbaz", opts);
```

--------------------------------

### Listen for Job Failure Event (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Shows how to set up an error handler for the 'failed' event on a BullMQ worker. This allows you to capture and handle exceptions that occur during job processing. Dependencies include 'bullmq'.

```typescript
worker.on('failed', (job: Job | undefined, error: Error, prev: string) => {
  // Do something with the return value.
});
```

--------------------------------

### Listen to Individual Job Events with QueueEventsPro in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/batches.md

Shows how to use `QueueEventsPro` to listen for events of individual jobs, even when they are processed as part of a batch. This provides a way to track the status of each job within a batch through global event listeners.

```typescript
import { QueueEventsPro } from '@taskforcesh/bullmq-pro';

const queueEvents = new QueueEventsPro(queueName, { connection });
queueEvents.on('completed', (jobId, err) => {
  // ...
});
```

--------------------------------

### Manually Fetch and Process a Job with BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

This snippet demonstrates how to instantiate a BullMQ worker without an automatic processor, fetch the next available job using `getNextJob`, and then manually move the job to a completed or failed state. It requires a unique token for job ownership and lock management.

```typescript
const worker = new Worker('my-queue');

// Specify a unique token
const token = 'my-token';

const job = (await worker.getNextJob(token)) as Job;

// Access job.data and do something with the job
// processJob(job.data)
if (succeeded) {
  await job.moveToCompleted('some return value', token, false);
} else {
  await job.moveToFailed(new Error('my error message'), token, false);
}

await worker.close();
```

--------------------------------

### Consume Jobs from a BullMQ Queue using a Worker (Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/python/introduction.md

This code snippet shows how to create and manage a BullMQ worker in Python to consume jobs from a queue. It includes a processor function to handle jobs, signal handling for graceful shutdown, and uses asyncio for concurrency. The worker can be configured with Redis connection details.

```python
from bullmq import Worker
import asyncio
import signal

async def process(job, job_token):
    # job.data will include the data added to the queue
    return doSomethingAsync(job)

async def main():

    # Create an event that will be triggered for shutdown
    shutdown_event = asyncio.Event()

    def signal_handler(signal, frame):
        print("Signal received, shutting down.")
        shutdown_event.set()

    # Assign signal handlers to SIGTERM and SIGINT
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    # Feel free to remove the connection parameter, if your redis runs on localhost
    worker = Worker("myQueue", process, {"connection": "rediss://<user>:<password>@<host>:<port>"})

    # Wait until the shutdown event is set
    await shutdown_event.wait()

    # close the worker
    print("Cleaning up worker...")
    await worker.close()
    print("Worker shut down successfully.")

if __name__ == "__main__":
    asyncio.run(main())
```

--------------------------------

### Initialize Worker with Worker Threads Enabled (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/sandboxed-processors.md

Initializes a BullMQ Worker with support for Node.js Worker Threads, which can be less resource-demanding than standard spawned processes. The 'useWorkerThreads: true' option must be provided.

```typescript
import { Worker } from 'bullmq'

const processorFile = path.join(__dirname, 'my_procesor.js');
worker = new Worker(queueName, processorFile, { useWorkerThreads: true });
```

--------------------------------

### BullMQ Pro Worker with Basic Observable Emission (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/observables/README.md

Demonstrates a BullMQ Pro worker that returns an RxJS Observable emitting multiple values and completing after a delay. It includes cleanup logic within the Observable's teardown function to clear intervals. This pattern is useful for tasks that produce intermediate results or require cleanup.

```typescript
import { WorkerPro } from "@taskforcesh/bullmq-pro"
import { Observable } from "rxjs"

const processor = async () => {
  return new Observable<number>(subscriber => {
    subscriber.next(1);
    subscriber.next(2);
    subscriber.next(3);
    const intervalId = setTimeout(() => {
      subscriber.next(4);
      subscriber.complete();
    }, 500);

    // Provide a way of canceling and disposing the interval resource
    return function unsubscribe() {
      clearInterval(intervalId);
    };
  });
};

const worker = new WorkerPro(queueName, processor, { connection });
```

--------------------------------

### Add Job with Binary Exponential Backoff and Options in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet demonstrates adding a job to a BullMQ queue with the custom 'binaryExponential' backoff strategy and specific options. The job has 10 attempts, and the backoff options include a delay of 500ms and truncation at 5 attempts.

```typescript
myQueue.add(
  { foo: "bar" },
  {
    attempts: 10,
    backoff: {
      type: "binaryExponential",
      options: {
        delay: 500,
        truncate: 5,
      },
    },
  }
);
```

--------------------------------

### Provide Default Environment Variable Values with TypeScript in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/troubleshooting.md

This snippet shows how to provide a default value for an environment variable if it's not defined or is empty when using BullMQ. This is useful for setting fallback queue names or other configurations, ensuring a valid value is always available.

```typescript
const queueName = process.env.QUEUE_NAME ?? 'defaultQueue';
```

--------------------------------

### Add FIFO Job with Completion/Failure Options

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/fifo.md

Illustrates adding a FIFO job to a BullMQ queue with specific options to control job removal upon completion or failure. Completed jobs are automatically removed, while the last 1000 failed jobs are retained. Requires the 'bullmq' library.

```typescript
await myQueue.add(
  'wall',
  { color: 'pink' },
  { removeOnComplete: true, removeOnFail: 1000 },
);
```

--------------------------------

### Register a Queue with BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Register a queue by importing BullModule.registerQueue() as a dynamic module. You can specify a name for the queue and optionally provide specific connection options that override the global configuration.

```typescript
BullModule.registerQueue({
  name: 'queueName',
});
```

```typescript
BullModule.registerQueue({
  name: 'queueName',
  connection: {
    host: '0.0.0.0',
    port: 6380,
  },
});
```

--------------------------------

### Return Next Job if Available in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Checks if a job was returned and creates a `Job` instance from its JSON representation. This is often used after fetching a job or transitioning its state, ensuring a usable `Job` object is available for further operations. It requires the queue instance, job data, and job ID.

```typescript
if (nextJobdata) {
  return Job.fromJSON(queue, nextJobData, nextJobId);
}
```

--------------------------------

### Manually Trim Queue Events (Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/README.md

Shows how to manually trim the event stream for a BullMQ queue using the `trimEvents` method in Python. This is useful for managing event history size and requires the 'bullmq' Python client.

```python
from bullmq import Queue

async def trim_queue_events():
    queue = Queue('paint')
    try:
        await queue.trim_events(10) # leaves 10 events
        print('Event stream trimmed successfully.')
    except Exception as e:
        print(f'Error trimming events: {e}')

# To run the async function:
import asyncio
asyncio.run(trim_queue_events())
```

--------------------------------

### Manually Trim Queue Events (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/README.md

Demonstrates how to manually trim the event stream for a BullMQ queue using the `trimEvents` method in TypeScript. This helps manage the size of the event history and requires the 'bullmq' package.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

async function trimQueueEvents() {
  try {
    await queue.trimEvents(10); // leaves 10 events
    console.log('Event stream trimmed successfully.');
  } catch (error) {
    console.error('Error trimming events:', error);
  }
}

trimQueueEvents();
```

--------------------------------

### Add Parent-Child Job Relationships with FlowProducer (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/README.md

Demonstrates advanced job management using `FlowProducer` to create complex job dependencies. This allows for defining parent-child relationships, enabling the execution of jobs in a structured, hierarchical manner.

```typescript
import { FlowProducer } from 'bullmq';

const flow = new FlowProducer();

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name: 'child-job',
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      children: [
        {
          name: 'grandchild-job',
          data: { idx: 1, foo: 'bah' },
          queueName: 'grandChildrenQueueName'
        },
        {
          name: 'grandchild-job',
          data: { idx: 2, foo: 'baz' },
          queueName: 'grandChildrenQueueName'
        },
      ],
    },
    {
      name: 'child-job',
      data: { idx: 3, foo: 'foo' },
      queueName: 'childrenQueueName'
    },
  ],
});
```

--------------------------------

### Add Job to BullMQ Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/README.md

Shows how to add a basic job to a BullMQ queue with a name and a payload. The job is stored in Redis and processed by available workers. This is a core method for queue operations.

```typescript
await queue.add('paint', { color: 'red' });
```

--------------------------------

### Add Jobs in Bulk to Multiple BullMQ Queues (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/adding-bulks.md

Adds multiple jobs to different BullMQ queues atomically using `FlowProducer.addBulk`. This function takes an array of job configurations, each specifying a name, queue name, and data. The operation succeeds only if all jobs are added; otherwise, it fails, ensuring data consistency. Dependencies include the `bullmq` library and a Redis connection.

```typescript
import { FlowProducer } from 'bullmq';

const flow = new FlowProducer({ connection });

const trees = await flow.addBulk([
  {
    name: 'job-1',
    queueName: 'queueName-1',
    data: {}
  },
  {
    name: 'job-2',
    queueName: 'queueName-2',
    data: {}
  },
]);
```

--------------------------------

### Sequential Job Processing with Switch Statements in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/process-step-jobs.md

This snippet demonstrates how to process jobs in sequential steps using a switch statement within a BullMQ worker. It updates job data to track the current step, ensuring proper retry behavior. Dependencies include BullMQ Worker and job.updateData.

```typescript
enum Step {
  Initial,
  Second,
  Finish,
}

const worker = new Worker(
  'queueName',
  async job => {
    let step = job.data.step;
    while (step !== Step.Finish) {
      switch (step) {
        case Step.Initial: {
          await doInitialStepStuff();
          await job.updateData({
            step: Step.Second,
          });
          step = Step.Second;
          break;
        }
        case Step.Second: {
          await doSecondStepStuff();
          await job.updateData({
            step: Step.Finish,
          });
          step = Step.Finish;
          return Step.Finish;
        }
        default: {
          throw new Error('invalid step');
        }
      }
    }
  },
  { connection },
);

```

```python
class Step(int, Enum):
  Initial = 1
  Second = 2
  Finish = 3

async def process(job: Job, token: str):
  step = job.data.get("step")
  while step != Step.Finish:
    if step == Step.Initial:
      await doInitialStepStuff()
      await job.updateData({
          "step": Step.Second
      })
      step = Step.Second
    elif step == Step.Second:
      await doSecondStepStuff()
      await job.updateData({
          "step": Step.Finish
      })
      step = Step.Finish
    else:
      raise Exception("invalid step")

worker = Worker("queueName", process, {"connection": connection})

```

--------------------------------

### Add Flows in Bulk with BullMQ FlowProducer (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/adding-bulks.md

Demonstrates using `FlowProducer.addBulk` to atomically add multiple job flows. This method ensures that either all jobs in the specified flows are added to Redis, or none are, providing transactional integrity. It can also improve performance by minimizing Redis network requests.

```typescript
import { FlowProducer } from 'bullmq';

const flow = new FlowProducer({ connection });

const trees = await flow.addBulk([
  {
    name: 'root-job-1',
    queueName: 'rootQueueName-1',
    data: {},
    children: [
      {
        name,
        data: { idx: 0, foo: 'bar' },
        queueName: 'childrenQueueName-1',
      },
    ],
  },
  {
    name: 'root-job-2',
    queueName: 'rootQueueName-2',
    data: {},
    children: [
      {
        name,
        data: { idx: 1, foo: 'baz' },
        queueName: 'childrenQueueName-2',
      },
    ],
  },
]);
```

--------------------------------

### Configure BullModule in AppModule

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/README.md

Configures the `BullModule` in the root `AppModule` by providing connection details for Redis. This sets up the global connection for all BullMQ services.

```typescript
import {
  Module
} from '@nestjs/common';
import {
  BullModule
} from '@nestjs/bullmq';

@Module({
  imports: [
    BullModule.forRoot({
      connection: {
        host: 'localhost',
        port: 6379,
      },
    }),
  ],
})
export class AppModule {}
```

--------------------------------

### Listen for Job Progress Event (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Illustrates how to listen for the 'progress' event emitted by a BullMQ worker. This event handler can process numerical or object-based progress updates from jobs. Dependencies include 'bullmq'.

```typescript
worker.on('progress', (job: Job, progress: number | object) => {
  // Do something with the return value.
});
```

--------------------------------

### Sandboxed Job Processing with Group ID in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/sandboxes-for-groups.md

This snippet demonstrates how to process jobs within a sandboxed environment using BullMQ Pro. It specifically shows how to access and assert the 'gid' property from the job object and verify group-related options. This is useful for scenarios where jobs are processed in groups and require group-specific context.

```typescript
import { SandboxedJobPro } from '@taskforcesh/bullmq-pro';

module.exports = function (job: SandboxedJobPro) {
  expect(job).to.have.property('gid');
  expect(job.opts).to.have.property('group');
  expect(job.opts.group).to.have.property('id');
  expect(job.opts.group.id).to.be.a('string');
  expect(job.opts.group.id).to.equal(job.gid);
};
```

--------------------------------

### Listen to Worker Events in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/events/README.md

This code shows how to subscribe to 'drained', 'completed', and 'failed' events from a BullMQ Worker instance using TypeScript. It depends on the 'bullmq' package and a connected Redis server.

```typescript
import { Worker, Job } from 'bullmq';

const myWorker = new Worker('Paint');

myWorker.on('drained', () => {
  // Queue is drained, no more jobs left
  console.log('Queue is drained.');
});

myWorker.on('completed', (job: Job) => {
  // job has completed
  console.log(`Job ${job.id} completed.`);
});

myWorker.on('failed', (job: Job) => {
  // job has failed
  console.log(`Job ${job.id} failed.`);
});
```

--------------------------------

### Implement a Processor with BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Define a processor class using the @Processor decorator to handle jobs for a specific queue. Extend WorkerHost and implement the process method. You can also use @OnWorkerEvent decorators to listen for job lifecycle events.

```typescript
import {
  Processor,
  WorkerHost,
  OnWorkerEvent,
} from '@taskforcesh/nestjs-bullmq-pro';
import { JobPro } from 'taskforcesh/bullmq-pro';

@Processor('queueName')
class TestProcessor extends WorkerHost {
  async process(job: JobPro<any, any, string>): Promise<any> {
    // do some stuff
  }

  @OnWorkerEvent('completed')
  onCompleted() {
    // do some stuff
  }
}
```

--------------------------------

### Add Prioritized Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/prioritized.md

Demonstrates how to add jobs to a BullMQ queue with different priority levels. Lower numerical values indicate higher priority. Jobs without assigned priorities are processed first.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

await myQueue.add('wall', { color: 'pink' }, { priority: 10 });
await myQueue.add('wall', { color: 'brown' }, { priority: 5 });
await myQueue.add('wall', { color: 'blue' }, { priority: 7 });

// The wall will be painted first brown, then blue and
// finally pink.
```

--------------------------------

### Configure BullMQ for Redis Cluster by Wrapping Queue Name

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/redis-cluster.md

This snippet shows an alternative method for configuring BullMQ with Redis clusters by wrapping the queue name itself in curly braces. Similar to using a prefix, this ensures that the queue's keys are treated as a hash tag, guaranteeing they reside on the same Redis cluster node. This approach is beneficial for maintaining the atomicity required by BullMQ operations within a clustered environment.

```typescript
const queue = new Queue('{cluster}');
```

--------------------------------

### Move Job to Wait due to Rate Limiting in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

This snippet demonstrates how to move a job back to the 'wait' state when the queue is rate-limited. It involves creating a job, fetching it, applying a rate limit to the queue, and then using `job.moveToWait(token)` to defer its processing.

```typescript
const worker = new Worker('my-queue', null, { connection, prefix });
const token = 'my-token';
await Job.create(queue, 'test', { foo: 'bar' });
const job = (await worker.getNextJob(token)) as Job;

await queue.rateLimit(60000);
await job.moveToWait(token);
```

--------------------------------

### Manual Job Retry in BullMQ with TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manual-retrying.md

This TypeScript code snippet demonstrates how to manually retry a BullMQ job. It uses the `moveToWait` method to move the job back to the wait queue and throws a `WaitingError` to prevent the worker from completing or failing the job. The `token` parameter is crucial for unlocking the job.

```typescript
import { WaitingError, Worker } from 'bullmq';

const worker = new Worker(
  'queueName',
  async (job: Job, token?: string) => {
    try {
      await doSomething();
    } catch (error) {
      await job.moveToWait(token);
      throw new WaitingError();
    }
  },
  { connection },
);

```

--------------------------------

### Configure BullMQ Queue Prefix for Redis Cluster (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/redis-cluster.md

Sets a queue prefix within brackets to ensure keys are placed in the same hash slot, making BullMQ compatible with Redis Cluster. This approach helps maintain atomic operations required by BullMQ.

```typescript
const queue = new Queue('cluster', {
  prefix: '{myprefix}',
});
```

--------------------------------

### Configure BullMQ to Fail Fast with Redis Down (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/failing-fast-when-redis-is-down.md

This snippet shows how to instantiate a BullMQ queue with `enableOfflineQueue: false`. This setting prevents the `add` command from queuing jobs when Redis is disconnected, instead throwing an exception. This is useful for API endpoints where long-running calls are undesirable. It depends on the BullMQ library and ioredis.

```typescript
const myQueue = new Queue("transcoding", {
  connection: {
    enableOfflineQueue: false,
  },
});

app.post("/jobs", async (req, res) => {
  try {
    const job = await myQueue.add("myjob", { req.body });
    res.status(201).json(job.id);
  }catch(err){
    res.status(503).send(err);
  }
})
```

--------------------------------

### Configure BullMQ for Redis Cluster with Prefix

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/redis-cluster.md

This snippet demonstrates how to configure a BullMQ queue to be compatible with a Redis cluster by specifying a prefix. The prefix, enclosed in curly braces, acts as a hash tag, ensuring that related keys are stored on the same Redis node. This is crucial for BullMQ's atomic operations. Ensure that prefixes are unique if multiple queues are used to maintain even distribution across cluster nodes.

```typescript
const queue = new Queue('cluster', {
  prefix: '{myprefix}'
});
```

--------------------------------

### Define Custom RRULE Repeat Strategy for BullMQ Queue and Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-strategies.md

This TypeScript code defines a custom repeat strategy for BullMQ queues and workers using the 'rrule' library. The strategy calculates the next job occurrence based on an RRULE pattern and the latest job's timestamp. It requires the 'rrule' package and should be configured in both Queue and Worker settings. The function handles potential errors like missing DTSTART for COUNT in RRULE.

```typescript
import { Queue, Worker } from 'bullmq';
import { rrulestr } from 'rrule';

const settings = {
  repeatStrategy: (millis: number, opts: RepeatOptions, _jobName: string) => {
    const currentDate = 
      opts.startDate && new Date(opts.startDate) > new Date(millis) 
        ? new Date(opts.startDate) 
        : new Date(millis);

    const rrule = rrulestr(opts.pattern);

    if (rrule.origOptions.count && !rrule.origOptions.dtstart) {
      throw new Error('DTSTART must be defined to use COUNT with rrule');
    }

    const next_occurrence = rrule.after(currentDate, false);
    return next_occurrence?.getTime();
  },
};

const myQueue = new Queue('Paint', { settings });

// Repeat job every 10 seconds
await myQueue.upsertJobScheduler(
  'collibris',
  {
    pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=10;WKST=MO',
  },
  {
    data: { color: 'green' },
  },
);

// Repeat job every 20 seconds
await myQueue.upsertJobScheduler(
  'pingeons',
  {
    pattern: 'RRULE:FREQ=SECONDLY;INTERVAL=20;WKST=MO',
  },
  {
    data: { color: 'gray' },
  },
);

const worker = new Worker(
  'Paint',
  async () => {
    doSomething();
  },
  { settings },
);

```

--------------------------------

### Add Repeatable Jobs with Specific Job IDs in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Demonstrates adding repeatable jobs to a BullMQ queue while specifying a unique `jobId`. This is important because the standard `jobId` option is used to generate unique IDs for repeatable jobs, preventing duplicates when jobs have the same name and options. Requires importing Queue and QueueScheduler.

```typescript
import { Queue, QueueScheduler } from 'bullmq';

const myQueueScheduler = new QueueScheduler('Paint');
const myQueue = new Queue('Paint');

// Repeat job every 10 seconds but no more than 100 times
await myQueue.add(
  'bird',
  { color: 'bird' },
  {
    repeat: {
      every: 10000,
      limit: 100,
    },
    jobId: 'colibri',
  },
);

await myQueue.add(
  'bird',
  { color: 'bird' },
  {
    repeat: {
      every: 10000,
      limit: 100,
    },
  },
);
```

--------------------------------

### Retrieve Prioritized Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/prioritized.md

Illustrates methods to fetch jobs that are currently in the 'prioritized' state from a BullMQ queue. This can be done using `getJobs` with a specific state or the dedicated `getPrioritized` method.

```typescript
const jobs = await queue.getJobs(['prioritized']);
```

```typescript
const jobs2 = await queue.getPrioritized();
```

--------------------------------

### Listen for Deduplicated Event in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

This snippet demonstrates how to use the QueueEvents class in BullMQ to listen for the 'deduplicated' event. It logs details about the job that was ignored and the existing job that caused the deduplication. This requires importing QueueEvents from 'bullmq'.

```typescript
import { QueueEvents } from 'bullmq';

const queueEvents = new QueueEvents('myQueue');

queueEvents.on(
  'deduplicated',
  ({ jobId, deduplicationId, deduplicatedJobId }, id) => {
    console.log(`Job ${deduplicatedJobId} was deduplicated due to existing job ${jobId} 
  with deduplication ID ${deduplicationId}`);
  },
);

```

--------------------------------

### Define and Register a Processor

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/README.md

Defines a processor class using the `@Processor` decorator and registers it as a provider. The processor handles jobs for a specific queue and can define event listeners.

```typescript
import {
  Processor,
  WorkerHost,
  OnWorkerEvent
} from '@nestjs/bullmq';
import {
  Job
} from 'bullmq';

@Processor('queueName')
class TestProcessor extends WorkerHost {
  async process(job: Job<any, any, string>): Promise<any> {
    // do some stuff
  }

  @OnWorkerEvent('completed')
  onCompleted() {
    // do some stuff
  }
}

// In AppModule:
@Module({
  imports: [
    BullModule.registerQueue({
      name: 'queueName',
      connection: {
        host: '0.0.0.0',
        port: 6380,
      },
    }),
    BullModule.registerFlowProducer({
      name: 'flowProducerName',
      connection: {
        host: '0.0.0.0',
        port: 6380,
      },
    }),
  ],
  providers: [TestProcessor],
})
export class AppModule {}
```

--------------------------------

### Validate Environment Variables with TypeScript in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/troubleshooting.md

This snippet demonstrates how to validate environment variables before using them with BullMQ to prevent errors. It checks if a required environment variable is defined and throws an error if it's not. This helps in failing fast and avoiding obscure Lua script errors.

```typescript
const queueName = process.env.QUEUE_NAME;
if (!queueName) {
  throw new Error("QUEUE_NAME is not defined or is empty.");
}

const queue = new Queue(queueName, { ... });
```

--------------------------------

### Configure Batch Processing with MinSize and Timeout in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/batches.md

Enhances batch processing configuration by introducing `minSize` and `timeout` options. `minSize` sets the minimum number of jobs required before processing, while `timeout` specifies the maximum wait time in milliseconds for `minSize` to be met. The worker processes jobs up to `size` limit, even if `minSize` is not reached within the `timeout`.

```typescript
const worker = new WorkerPro(
  'My Queue',
  async (job: JobPro) => {
    const batch = job.getBatch();
    for (let i = 0; i < batch.length; i++) {
      const batchedJob = batch[i];
      await doSomethingWithBatchedJob(batchedJob);
    }
  },
  {
    connection,
    batch: {
      size: 10,      // Maximum jobs per batch
      minSize: 5,    // Wait for at least 5 jobs
      timeout: 30_000 // Wait up to 30 seconds
    },
  },
);
```

--------------------------------

### Add Job to Waiting Queue in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Adds a new job to the 'waiting' queue in BullMQ. This method is part of the manual job fetching pattern. It requires a BullMQ Queue instance and accepts job data as an argument. The `limiter` configuration is crucial for controlling job processing rates.

```typescript
import Queue from 'bull';

const queue = new Queue({
  limiter: {
    max: 5,
    duration: 5000,
    bounceBack: true // important
  },
  ...queueOptions
});
queue.add({ random_attr: 'random_value' });
```

--------------------------------

### Pull Job from Waiting Queue in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Retrieves the next available job from the 'waiting' queue in BullMQ, preparing it for manual processing. This is a key step in the manual job fetching workflow. The method returns a `Job` object, which can then be manipulated or transitioned to other states.

```typescript
const job: Job = await queue.getNextJob();
```

--------------------------------

### Register Processor in AppModule

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Register the created processor as a provider in your AppModule. Ensure that the queue and flow producer it depends on are also registered within the same module's imports.

```typescript
import {
  Module
} from '@nestjs/common';
import {
  BullModule
} from '@taskforcesh/nestjs-bullmq-pro';
import { TestProcessor } from './test.processor'; // Assuming processor is in test.processor.ts

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'queueName',
      connection: {
        host: '0.0.0.0',
        port: 6380,
      },
    }),
    BullModule.registerFlowProducer({
      name: 'flowProducerName',
      connection: {
        host: '0.0.0.0',
        port: 6380,
      },
    }),
  ],
  providers: [TestProcessor],
})
export class AppModule {}
```

--------------------------------

### Register a Queue with BullModule

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/README.md

Dynamically registers a queue with a specified name using `BullModule.registerQueue()`. This allows the application to interact with a specific queue.

```typescript
BullModule.registerQueue({
  name: 'queueName',
});
```

--------------------------------

### Attach Error Listener to Worker (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/README.md

Explains the importance of attaching an 'error' event listener to a BullMQ worker to prevent unhandled exceptions and ensure continuous job processing. Dependencies include 'bullmq'.

```typescript
worker.on('error', err => {
  // log the error
  console.error(err);
});
```

--------------------------------

### Injecting a BullMQ Queue in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/producers.md

Demonstrates how to inject a BullMQ queue (QueuePro) into a NestJS service using the `@InjectQueue()` decorator. This allows the service to interact with the specified queue for adding jobs.

```typescript
import { Injectable } from '@nestjs/common';
import { QueuePro } from 'taskforcesh/bullmq-pro';
import { InjectQueue } from '@taskforcesh/nestjs-bullmq-pro';

@Injectable()
export class AudioService {
  constructor(@InjectQueue('audio') private audioQueue: QueuePro) {}
}
```

--------------------------------

### Set Max Group Size for Jobs in BullMQ Pro (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/max-group-size.md

Demonstrates how to set a maximum size for a job group using the `maxSize` option in BullMQ Pro. It includes importing necessary classes, creating a QueuePro instance, adding a job with group options, and handling the `GroupMaxSizeExceededError` if the group limit is reached. This method is for individual job additions.

```typescript
import { QueuePro, GroupMaxSizeExceededError } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue', { connection });
const groupId = 'my group';
try {
  await queue.add('paint', { foo: 'bar' }, {
      group: {
        id: groupId,
        maxSize: 7,
      },
    });
} catch (err) {
  if (err instanceof GroupMaxSizeExceededError){
    console.log(`Job discarded for group ${groupId}`)
  } else {
    throw err;
  }
}
```

--------------------------------

### Process Job with Error-Based Backoff and Add Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet shows how to process jobs in BullMQ, throwing different errors to test the custom backoff strategy. It then adds two jobs with the same backoff strategy ('foo'), one designed to throw a generic error and the other a 'MySpecificError'.

```typescript
myQueue.process(function (job, done) {
  if (job.data.msg === 'Specific Error') {
    throw new MySpecificError();
  } else {
    throw new Error();
  }
});

myQueue.add({ msg: 'Hello' }, {
  attempts: 3,
  backoff: {
    type: 'foo'
  }
});

myQueue.add({ msg: 'Specific Error' }, {
  attempts: 3,
  backoff: {
    type: 'foo'
  }
});
```

--------------------------------

### Registering a BullMQ Queue Events Listener in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/queue-events-listeners.md

This snippet shows how to use the `@QueueEventsListener` decorator from `@taskforcesh/nestjs-bullmq-pro` to create a listener for queue events. The `TestQueueEvents` class extends `QueueEventsHost` and uses the `@OnQueueEvent('completed')` decorator to handle job completion, extracting the `jobId`. This requires importing necessary components from the library.

```typescript
import {
  QueueEventsListener,
  QueueEventsHost,
  OnQueueEvent,
} from '@taskforcesh/nestjs-bullmq-pro';

@QueueEventsListener('queueName')
export class TestQueueEvents extends QueueEventsHost {
  @OnQueueEvent('completed')
  onCompleted({
    jobId,
  }: {
    jobId: string;
    returnvalue: string;
    prev?: string;
  }) {
    // do some stuff
  }
}
```

--------------------------------

### Define Binary Exponential Backoff Strategy with Options in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet defines a custom 'binaryExponential' backoff strategy in BullMQ. It calculates a randomized delay based on the number of attempts made, with options for base delay and truncation. The strategy handles potential undefined options.

```typescript
const Queue = require("bull");

const myQueue = new Queue("Server B", {
  settings: {
    backoffStrategies: {
      // truncated binary exponential backoff
      binaryExponential: function (attemptsMade, err, options) {
        // Options can be undefined, you need to handle it by yourself
        if (!options) {
          options = {};
        }
        const delay = options.delay || 1000;
        const truncate = options.truncate || 1000;
        console.error({ attemptsMade, err, options });
        return Math.round(
          Math.random() *
            (Math.pow(2, Math.min(attemptsMade, truncate)) - 1) *
            delay
        );
      },
    },
  },
});
```

--------------------------------

### Retrieve BullMQ Jobs from a Group with Pagination (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/getters.md

Retrieves a paginated list of jobs belonging to a specific group in BullMQ. This allows for efficient fetching of jobs without overwhelming the system, suitable for displaying jobs in UI elements.

```typescript
const jobs = await queue.getGroupJobs(groupId, 0, 100);
```

--------------------------------

### BullMQ Persistent Message Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/message-queue.md

Implements a persistent message queue using BullMQ. Server A sends messages to Server B's queue, and Server B processes incoming messages. This allows servers to communicate even if they are not online simultaneously, creating a robust communication channel. Requires the 'bull' package.

```typescript
const Queue = require('bull');

const sendQueue = new Queue('Server B');
const receiveQueue = new Queue('Server A');

receiveQueue.process(function (job, done) {
  console.log('Received message', job.data.msg);
  done();
});

sendQueue.add({ msg: 'Hello' });
```

```typescript
const Queue = require('bull');

const sendQueue = new Queue('Server A');
const receiveQueue = new Queue('Server B');

receiveQueue.process(function (job, done) {
  console.log('Received message', job.data.msg);
  done();
});

sendQueue.add({ msg: 'World' });
```

--------------------------------

### Set Default Exponential Backoff Options in BullMQ Queue

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This code snippet illustrates how to define the exponential backoff strategy within the `defaultJobOptions` of a BullMQ queue. When set at the queue level, these options apply to all jobs added to that queue unless explicitly overridden during job creation. This simplifies configuration by ensuring a consistent retry strategy across multiple jobs.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo', {
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000,
    },
  },
});

await queue.add('test-retry', { foo: 'bar' });

```

--------------------------------

### Using a Custom Backoff Strategy When Adding Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This snippet demonstrates how to specify a custom backoff strategy when adding a job to a BullMQ queue. By setting the `type` to 'custom' within the `backoff` options, the job will use the custom strategy defined in the worker's settings. This allows for flexible retry behaviors tailored to specific job types or failure conditions.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 3,
    backoff: {
      type: 'custom',
    },
  },
);

```

--------------------------------

### Retrieve Batch Jobs from Event Handler in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/batches.md

Demonstrates how to access individual jobs within a batch from a worker's event listener. The `job.getBatch()` method is used on the event object (which represents the dummy batch job) to retrieve the array of actual jobs processed in that batch.

```typescript
worker.on('completed', job => {
  const batch = job.getBatch();
  // ...
});
```

--------------------------------

### Process Grouped Jobs with BullMQ Pro Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/README.md

Illustrates how to set up a BullMQ Pro worker to process jobs, including those that are part of a group. The worker can optionally perform specific actions based on the job's group.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';

const worker = new WorkerPro('test', async job => {
  // Do something usefull.

  // You can also do something different depending on the group
  await doSomethingSpecialForMyGroup(job.opts.group);
});
```

--------------------------------

### Adding a Job to a BullMQ Queue in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/producers.md

Shows how to add a new job to an injected BullMQ queue using the `add()` method. The method accepts job data as an argument and returns a Promise that resolves with the created job object.

```typescript
const job = await this.audioQueue.add({
  foo: 'bar',
});
```

--------------------------------

### Set BullMQ Global Rate Limit (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/global-rate-limit.md

Sets the global rate limit for a BullMQ queue, specifying the maximum number of jobs to process within a given time interval. This is useful for controlling the overall throughput of the queue. It takes the number of jobs and the time interval in milliseconds as arguments.

```typescript
import { Queue } from 'bullmq';

// 1 job per second
await queue.setGlobalRateLimit(1, 1000);
```

--------------------------------

### Register QueueEventsListener with NestJS BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/queue-events-listeners.md

Demonstrates how to use the `@QueueEventsListener` decorator to create a listener for queue events in NestJS. This listener extends `QueueEventsHost` and can handle specific events like 'completed' using the `@OnQueueEvent` decorator. It requires importing necessary components from '@nestjs/bullmq'.

```typescript
import {
  QueueEventsListener,
  QueueEventsHost,
  OnQueueEvent,
} from '@nestjs/bullmq';

@QueueEventsListener('queueName')
export class TestQueueEvents extends QueueEventsHost {
  @OnQueueEvent('completed')
  onCompleted({
    jobId,
  }: {
    jobId: string;
    returnvalue: string;
    prev?: string;
  }) {
    // do some stuff
  }
}
```

--------------------------------

### BullMQ Listener for Completed Job Results (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/returning-job-data.md

Shows how to listen for the 'completed' event on a BullMQ queue to retrieve the return value from a processed job. It fetches the job using its ID and logs the 'returnvalue'.

```typescript
import { Job, QueueEvents, Queue } from 'bullmq';

const queue = new Queue('AsyncProc');
const queueEvents = new QueueEvents('AsyncProc');

queueEvents.on('completed', async ({ jobId: string }) => {
  const job = await Job.fromId(queue, jobId);

  console.log(job.returnvalue);
});
```

--------------------------------

### Move Job to Completed Queue in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Marks a job as 'completed' in BullMQ after successful processing. This method requires the `Job` object, a status string (e.g., 'succeeded'), and a boolean to indicate if logs should be kept. It returns the data and ID of the next job.

```typescript
const (nextJobData, nextJobId) = await job.moveToCompleted('succeeded', true);
```

--------------------------------

### Register a Flow Producer with BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/README.md

Register a flow producer by importing BullModule.registerFlowProducer() as a dynamic module. Similar to queues, you can assign a name and configure specific connection details.

```typescript
BullModule.registerFlowProducer({
  name: 'flowProducerName',
});
```

```typescript
BullModule.registerFlowProducer({
  name: 'flowProducerName',
  connection: {
    host: '0.0.0.0',
    port: 6380,
  },
});
```

--------------------------------

### Inject BullMQ Queue into NestJS Service

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/producers.md

This snippet shows how to inject a BullMQ `Queue` instance into a NestJS service using the `@InjectQueue()` decorator. This allows the service to add jobs to the specified queue. It requires the `bullmq` package and NestJS DI system.

```typescript
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';

@Injectable()
export class AudioService {
  constructor(@InjectQueue('audio') private audioQueue: Queue) {}
}
```

--------------------------------

### Dynamic Child Job Addition in BullMQ Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/process-step-jobs.md

Demonstrates how to add child jobs dynamically within a BullMQ worker's processor function using FlowProducer. This allows for complex, multi-stage processing where subsequent steps depend on the completion of generated child jobs. The code includes error handling for waiting on children.

```typescript
import { FlowProducer, WaitingChildrenError, Worker } from 'bullmq';

enum Step {
  Initial,
  Second,
  Third,
  Finish,
}

const flow = new FlowProducer({ connection });
const worker = new Worker(
  'parentQueueName',
  async (job, token) => {
    let step = job.data.step;
    while (step !== Step.Finish) {
      switch (step) {
        case Step.Initial: {
          await doInitialStepStuff();
          await flow.add({
            name: 'child-job',
            queueName: 'childrenQueueName',
            data: {},
            children: [
              {
                name,
                data: { idx: 0, foo: 'bar' },
                queueName: 'grandchildrenQueueName',
              },
              {
                name,
                data: { idx: 1, foo: 'baz' },
                queueName: 'grandchildrenQueueName',
              },
            ],
            opts: {
              parent: {
                id: job.id,
                queue: job.queueQualifiedName,
              },
            },
          });

          await job.updateData({
            step: Step.Second,
          });
          step = Step.Second;
          break;
        }
        case Step.Second: {
          await doSecondStepStuff();
          await job.updateData({
            step: Step.Third,
          });
          step = Step.Third;
          break;
        }
        case Step.Third: {
          const shouldWait = await job.moveToWaitingChildren(token);
          if (!shouldWait) {
            await job.updateData({
              step: Step.Finish,
            });
            step = Step.Finish;
            return Step.Finish;
          } else {
            throw new WaitingChildrenError();
          }
        }
        default: {
          throw new Error('invalid step');
        }
      }
    }
  },
  { connection },
);

```

--------------------------------

### Configure Group Key Rate Limiter for BullMQ Queue and Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/rate-limiting.md

Enables rate limiting based on a 'groupKey' (e.g., 'customerId') for both the BullMQ queue and its workers. This allows for per-group rate limiting instead of a global one. Supports older versions of BullMQ (pre-3.0).

```typescript
import { Queue, Worker, QueueScheduler } from 'bullmq';

const queue = new Queue('painter', {
  limiter: {
    groupKey: 'customerId',
  },
});

const worker = new Worker('painter', async job => paintCar(job), {
  limiter: {
    max: 10,
    duration: 1000,
    groupKey: 'customerId',
  },
});

const scheduler = new QueueScheduler('painter');

// jobs will be rate limited by the value of customerId key:
await queue.add('rate limited paint', { customerId: 'my-customer-id' });
```

--------------------------------

### Add Jobs in Bulk (TypeScript, Python)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/adding-bulks.md

Adds multiple jobs to a BullMQ queue atomically. This method ensures all jobs are added or none are, which is useful for maintaining data integrity. It can also be more performant than adding jobs individually by reducing network roundtrips to Redis. The method takes an array of job objects, each with a 'name' and 'data' property.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

const name = 'jobName';
const jobs = await queue.addBulk([
  { name, data: { paint: 'car' } },
  { name, data: { paint: 'house' } },
  { name, data: { paint: 'boat' } },
]);
```

```python
from bullmq import Queue

queue = Queue("paint")

jobs = await queue.addBulk([
  { "name": "jobName", "data": { "paint": "car" } },
  { "name": "jobName", "data": { "paint": "house" } },
  { "name": "jobName", "data": { "paint": "boat" } }
])
```

--------------------------------

### Adding a Job Flow with FlowProducer in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Demonstrates how to add a job flow with parent-child relationships using the `FlowProducer` class in TypeScript. The `add` method accepts a `FlowJob` object, which can include nested `children` jobs. A connection object can be optionally passed to the `FlowProducer` constructor.

```typescript
import { FlowProducer } from 'bullmq';

// A FlowProducer constructor takes an optional "connection"
// object otherwise it connects to a local redis instance.
const flowProducer = new FlowProducer();

const flow = await flowProducer.add({
  name: 'renovate-interior',
  queueName: 'renovate',
  children: [
    { name: 'paint', data: { place: 'ceiling' }, queueName: 'steps' },
    { name: 'paint', data: { place: 'walls' }, queueName: 'steps' },
    { name: 'fix', data: { place: 'floor' }, queueName: 'steps' },
  ],
});
```

--------------------------------

### Add Flow with Fail Parent Option - TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/fail-parent.md

Demonstrates how to add a job flow where child jobs can trigger the failure of their parent jobs if they fail. This is achieved by setting the `failParentOnFailure: true` option on the child jobs. The effect can propagate recursively up the job hierarchy. Dependencies include the 'bullmq' library.

```typescript
import { FlowProducer } from 'bullmq';

const flow = new FlowProducer({ connection });

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name: 'child-job-1',
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      // This child will fail its parent if it fails
      opts: { failParentOnFailure: true },
      children: [
        {
          name: 'grandchild-job-1',
          data: { idx: 1, foo: 'bah' },
          queueName: 'grandChildrenQueueName',
          // This grandchild will fail its parent if it fails
          opts: { failParentOnFailure: true },
        },
        {
          name: 'grandchild-job-2',
          data: { idx: 2, foo: 'baz' },
          queueName: 'grandChildrenQueueName',
          // No failParentOnFailure; its failure won't affect the parent
        },
      ],
    },
    {
      name: 'child-job-2',
      data: { idx: 3, foo: 'foo' },
      queueName: 'childrenQueueName',
      // No failParentOnFailure; its failure won't affect the parent
    },
  ],
});
```

--------------------------------

### Remove Repeatable Jobs by Key or Name with BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/repeatable.md

Shows how to remove repeatable jobs from a BullMQ queue. Jobs can be removed either by their unique repeatable job key using `removeRepeatableByKey` or by their name and repeat options using `removeRepeatable`. This requires importing the Queue class.

```typescript
import { Queue } from 'bullmq';

const repeat = { pattern: '*/1 * * * * *' };

const myQueue = new Queue('Paint');

const job1 = await myQueue.add('red', { foo: 'bar' }, { repeat });
const job2 = await myQueue.add('blue', { foo: 'baz' }, { repeat });

const isRemoved1 = await myQueue.removeRepeatableByKey(job1.repeatJobKey);
const isRemoved2 = await queue.removeRepeatable('blue', repeat);
```

--------------------------------

### Create Deep Job Hierarchies with FlowProducer

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Illustrates the creation of deeply nested job hierarchies using FlowProducer, where jobs depend on each other for serial execution. This allows for complex, multi-step processes to be managed effectively. Available in TypeScript and Python.

```typescript
import { FlowProducer } from 'bullmq';
const flowProducer = new FlowProducer();

const queueName = 'assembly-line';
const chain = await flowProducer.add({
  name: 'car',
  data: { step: 'engine' },
  queueName,
  children: [
    {
      name: 'car',
      data: { step: 'wheels' },
      queueName,
      children: [{ name: 'car', data: { step: 'chassis' }, queueName }],
    },
  ],
});

```

```python
from bullmq import FlowProducer

flowProducer = FlowProducer()

queueName = 'assembly-line'
chain = await flowProducer.add({
  "name": "car",
  "data": { "step": "engine" },
  "queueName": queueName,
  "children": [
    {
      "name": "car",
      "data": { "step": "wheels" },
      "queueName": queueName,
      "children": [{ "name": "car", "data": { "step": "chassis" }, "queueName": queueName }],
    },
  ],
})

```

--------------------------------

### Configure Exponential Backoff with Delay in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/retrying-failing-jobs.md

This snippet shows how to configure the built-in 'exponential' backoff function with a specific delay for job retries in BullMQ. It sets the maximum number of attempts and defines the backoff strategy with a 1-second delay, resulting in retries spaced at 1, 2, and 4 seconds. This is useful for managing retry frequency and preventing immediate re-attempts after a failure.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('foo');

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 1000,
    },
  },
);

```

--------------------------------

### Limit Job Scheduler Repetitions with limit

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-options.md

Restricts the total number of times a job scheduler will produce jobs. Once the specified `limit` is reached, no further jobs will be scheduled for that configuration. This is useful for tasks that should only run a finite number of times.

```typescript
await myQueue.upsertJobScheduler(
  'limited-job',
  {
    every: 10000, // every 10 seconds
    limit: 10, // limit to 10 executions
  },
  {
    name: 'limited-execution-job',
    data: { message: 'Limited runs' },
  },
);
```

--------------------------------

### Add Flow with Queue Options in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Adds a job flow using `FlowProducer`, allowing specific options for queues involved in the flow. Options like `defaultJobOptions` can be configured per queue, affecting all jobs added to that queue within the flow.

```typescript
import { FlowProducer } from 'bullmq';
const flowProducer = new FlowProducer();

const queueName = 'assembly-line';
const chain = await flowProducer.add(
  {
    name: 'car',
    data: { step: 'engine' },
    queueName,
    children: [
      {
        name: 'car',
        data: { step: 'wheels' },
        queueName,
      },
    ],
  },
  {
    queuesOptions: {
      [queueName]: {
        defaultJobOptions: {
          removeOnComplete: true,
        },
      },
    },
  },
);
```

--------------------------------

### Implement TTL for BullMQ Sandboxed Processor (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/timeout-for-sandboxed-processors.md

This TypeScript code snippet demonstrates a pattern for applying a time-to-live (TTL) mechanism to a sandboxed processor in BullMQ. It uses two timeouts: a hard kill timeout that exits the process and a soft kill timeout that attempts a cleanup operation before exiting. The 'hasCompleted' flag prevents premature timeouts after the job has finished. It's crucial to clear these timeouts when the job completes to ensure the process can be reused.

```typescript
const MAX_TTL = 30_000;

// The processor will have a cleanup timeout of 5 seconds.
const CLEANUP_TTL = 5_000;

// We use a custom exit code to mark the TTL, but any would do in practice
// as long as it is < 256 (Due to Unix limitation to 8 bits per exit code)
const TTL_EXIT_CODE = 10;

module.exports = async function (job) {
  let hasCompleted = false;
  const harKillTimeout = setTimeout(() => {
    if (!hasCompleted) {
      process.exit(TTL_EXIT_CODE);
    }
  }, MAX_TTL);

  const softKillTimeout = setTimeout(async () => {
    if (!hasCompleted) {
      await doCleanup(job);
    }
  }, CLEANUP_TTL);

  try {
    // If doAsyncWork is CPU intensive and blocks NodeJS loop forever,
    // the timeout will never be triggered either.
    await doAsyncWork(job);
    hasCompleted = true;
  } finally {
    // Important to clear the timeouts before returning as this process will be reused.
    clearTimeout(harKillTimeout);
    clearTimeout(softKillTimeout);
  }
};

const doAsyncWork = async job => {
  // Simulate a long running operation.
  await new Promise(resolve => setTimeout(resolve, 10000));
};

const doCleanup = async job => {
  // Simulate a cleanup operation.
  await job.updateProgress(50);
};
```

--------------------------------

### Retrieve Ignored Child Job Failures (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/ignore-dependency.md

This code snippet shows how to retrieve a list of child jobs that failed but were ignored by their parent due to the `ignoreDependencyOnFailure` option. It uses the `getIgnoredChildrenFailures` method on the job object representing the root of the flow. This is useful for monitoring and understanding which dependencies were skipped.

```typescript
const ignoredChildrenFailures = 
  await originalTree.job.getIgnoredChildrenFailures();
```

--------------------------------

### Add Grouped Jobs to BullMQ Pro Queue

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/README.md

Demonstrates how to add jobs to a BullMQ Pro queue with a specified group ID. This ensures that jobs belonging to the same group are processed sequentially relative to other jobs in that group.

```typescript
import { QueuePro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro();

const job1 = await queue.add(
  'test',
  { foo: 'bar1' },
  {
    group: {
      id: 1,
    },
  },
);

const job2 = await queue.add(
  'test',
  { foo: 'bar2' },
  {
    group: {
      id: 2,
    },
  },
);
```

--------------------------------

### Resume Job Group

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/pausing-groups.md

Resumes a previously paused job group, allowing workers to pick up jobs from it again.

```APIDOC
## POST /queue/{queueName}/resumeGroup

### Description
Resumes a previously paused job group, allowing workers to process jobs from this group again.

### Method
POST

### Endpoint
`/queue/{queueName}/resumeGroup`

### Parameters
#### Path Parameters
- **queueName** (string) - Required - The name of the queue.

#### Query Parameters
- **groupId** (string) - Required - The ID of the group to resume.

### Request Example
```json
{
  "groupId": "myGroupId"
}
```

### Response
#### Success Response (200)
- **success** (boolean) - True if the group was successfully resumed, false if the group did not exist or was already resumed.

#### Response Example
```json
{
  "success": true
}
```
```

--------------------------------

### Move Job to Failed Queue in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Transitions a job to the 'failed' queue in BullMQ, typically used when an error occurs during processing. This method requires the `Job` object and accepts an error message and a boolean indicating whether to log the error. It returns the data and ID of the next job in the queue.

```typescript
const (nextJobData, nextJobId) = await job.moveToFailed(
  {
    message: 'Call to external service failed!',
  },
  true,
);
```

--------------------------------

### BullMQ Pro Worker with Stateful Observable for Job Resumption (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/observables/README.md

Illustrates a BullMQ Pro worker utilizing an RxJS Observable to handle job resumption based on a previous return value. The switch statement within the observable logic allows the job to continue from a specific state. This is beneficial for long-running or complex processes that might need to be retried or paused.

```typescript
import { WorkerPro } from "@taskforcesh/bullmq-pro"
import { Observable } from "rxjs"

const processor = async (job) => {
  return new Observable<number>(subscriber => {
    switch(job.returnvalue){
      default:
        subscriber.next(1);
      case 1:
        subscriber.next(2);
      case 2:
        subscriber.next(3);
      case 3:
        subscriber.complete();
    }
  });
};

const worker = new WorkerPro(queueName, processor, { connection });
```

--------------------------------

### Injecting a BullMQ Flow Producer in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/nestjs/producers.md

Illustrates how to inject a BullMQ Flow Producer (FlowProducerPro) into a NestJS service using the `@InjectFlowProducer()` decorator. This enables the service to manage complex job flows within BullMQ.

```typescript
import { Injectable } from '@nestjs/common';
import { FlowProducerPro } from 'taskforcesh/bullmq-pro';
import { InjectFlowProducer } from '@taskforcesh/nestjs-bullmq-pro';

@Injectable()
export class FlowService {
  constructor(
    @InjectFlowProducer('flow') private fooFlowProducer: FlowProducerPro,
  ) {}
}
```

--------------------------------

### BullMQ Worker Returning Async Result (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/returning-job-data.md

Demonstrates a BullMQ worker processing an asynchronous task and returning its result. The returned data is accessible via the job's 'returnvalue' property after completion.

```typescript
import { Queue, Worker } from 'bullmq';

const myWorker = new Worker('AsyncProc', async job => {
  const result = await doSomeAsyncProcessing();
  return result;
});
```

--------------------------------

### Add Job to BullMQ Queue in NestJS

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/producers.md

Demonstrates how to add a single job to an injected BullMQ queue. The `add()` method takes a job name and optional data payload. This is a fundamental operation for any producer. It assumes a `Queue` instance has already been injected.

```typescript
const job = await this.audioQueue.add('sample', {
  foo: 'bar',
});
```

--------------------------------

### Conditional Job Processing with Named Processors in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/named-processor.md

This snippet demonstrates how to create a BullMQ worker that handles different job types using a switch case based on the job's name. It allows for distinct processing logic for various tasks within the same queue.

```typescript
const worker = new Worker(
  'queueName',
  async job => {
    switch (job.name) {
      case 'taskType1': {
        await doSomeLogic1();
        break;
      }
      case 'taskType2': {
        await doSomeLogic2();
        break;
      }
    }
  },
  { connection },
);

```

--------------------------------

### Extend Job Lock in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/manually-fetching-jobs.md

Extends the lock duration for a currently processing job in BullMQ to prevent it from being marked as stalled. This is crucial when a job takes longer than the default lock time (30 seconds). The `extendLock` method takes the desired new duration in seconds.

```typescript
job.extendLock(duration);
```

--------------------------------

### BullMQ FlowJob Interface Definition

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Defines the TypeScript interface for a `FlowJob`, which includes properties for the job's name, queue name, optional data, prefix, job options, and an array of child `FlowJob` objects.

```typescript
interface FlowJob {
  name: string;
  queueName: string;
  data?: any;
  prefix?: string;
  opts?: Omit<JobsOptions, 'parent' | 'repeat'>;
  children?: FlowJob[];
}
```

--------------------------------

### Configure FlowProducer to Ignore Child Job Failures (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/ignore-dependency.md

This snippet demonstrates how to configure a BullMQ `FlowProducer` to ignore failures in child jobs. The `ignoreDependencyOnFailure: true` option is applied to specific child jobs. This ensures that the parent job can complete even if these children fail, by not considering their failure as a dependency blocking the parent's progress. It shows the structure of nested jobs and how to define options for them.

```typescript
const flow = new FlowProducer({ connection });

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name, // Assuming 'name' is defined elsewhere, e.g., 'const name = "my-job";'
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      opts: { ignoreDependencyOnFailure: true },
      children: [
        {
          name,
          data: { idx: 1, foo: 'bah' },
          queueName: 'grandChildrenQueueName',
        },
        {
          name,
          data: { idx: 2, foo: 'baz' },
          queueName: 'grandChildrenQueueName',
        },
      ],
    },
    {
      name,
      data: { idx: 3, foo: 'foo' },
      queueName: 'childrenQueueName',
    },
  ],
});
```

--------------------------------

### BullMQ Job Handler Function (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/stalled.md

This snippet defines the handler function for a BullMQ job, named 'painter'. This function will be executed when a job is processed by the worker. It receives the job object as an argument. The current implementation is a placeholder for the actual painting logic.

```typescript
export default = (job) => {
    // Paint something
}
```

--------------------------------

### Resume a Job Group in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/pausing-groups.md

Resumes a previously paused job group by calling the `resumeGroup` method on a Queue instance. This allows workers to resume processing jobs from the specified group. Returns `false` if the group doesn't exist or is already resumed.

```typescript
await myQueue.resumeGroup('groupId');
```

--------------------------------

### Delaying Jobs in BullMQ with moveToDelayed

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/process-step-jobs.md

This snippet illustrates how to delay a job during its processing in BullMQ using the `moveToDelayed` method. It requires passing the job's lock token and throwing a `DelayedError` to signal the delay, preventing the worker from completing or failing the job. Dependencies include BullMQ Worker, DelayedError, and job.moveToDelayed.

```typescript
import { DelayedError, Worker } from 'bullmq';

enum Step {
  Initial,
  Second,
  Finish,
}

const worker = new Worker(
  'queueName',
  async (job: Job, token?: string) => {
    let step = job.data.step;
    while (step !== Step.Finish) {
      switch (step) {
        case Step.Initial: {
          await doInitialStepStuff();
          await job.moveToDelayed(Date.now() + 200, token);
          await job.updateData({
            step: Step.Second,
          });
          throw new DelayedError();
        }
        case Step.Second: {
          await doSecondStepStuff();
          await job.updateData({
            step: Step.Finish,
          });
          step = Step.Finish;
        }
        default: {
          throw new Error('invalid step');
        }
      }
    }
  },
  { connection },
);

```

--------------------------------

### Implement Manual Rate Limiting in BullMQ Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/rate-limiting.md

Allows manual control over rate limiting within a BullMQ worker by using the `rateLimit` method. This is useful when an external API returns a '429 Too Many Requests' status. It requires throwing a specific `Worker.RateLimitError` to move the job back to the waiting state.

```typescript
import { Worker } from 'bullmq';

const worker = new Worker(
  'myQueue',
  async () => {
    const [isRateLimited, duration] = await doExternalCall();
    if (isRateLimited) {
      await worker.rateLimit(duration);
      // Do not forget to throw this special exception,
      // since we must differentiate this case from a failure
      // in order to move the job to wait again.
      throw Worker.RateLimitError();
    }
  },
  {
    connection,
    limiter: {
      max: 1,
      duration: 500,
    },
  },
);
```

--------------------------------

### BullMQ Debounce Mode Deduplication (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

Implements debounce by setting a delay, TTL, and enabling extend and replace options for deduplication. If a job with the same ID is added during the delay/TTL, it replaces the previous job and resets the TTL, ensuring only the latest version is processed. Requires BullMQ Queue and Worker imports.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

const worker = new Worker('Paint', async () => {});

worker.once('completed', job => {
  // only one instance is completed and
  // 9 additions were ignored
  console.log(job.data.color); // `white 10`
});

// Add 10 jobs with deduplication option in debounce mode.
for (let i = 1; i < 11; i++) {
  await myQueue.add(
    'house1',
    { color: `white ${i}` },
    {
      deduplication: {
        id: 'customValue',
        ttl: 5000,
        extend: true,
        replace: true,
      },
      delay: 5000,
    },
  );
}
```

--------------------------------

### Handle Failing Jobs Individually in BullMQ Pro Batches

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/batches.md

Implements custom error handling for jobs within a batch. Instead of the entire batch failing when an exception occurs, this code uses `batchedJob.setAsFailed(err)` to mark only the specific job that caused the error as failed. Other jobs in the batch will complete successfully.

```typescript
const worker = new WorkerPro(
  'My Queue',
  async (job: JobPro) => {
    const batch = job.getBatch();

    for (let i = 0; i < batch.length; i++) {
      const batchedJob = batch[i];
      try {
        await doSomethingWithBatchedJob(batchedJob);
      } catch (err) {
        batchedJob.setAsFailed(err);
      }
    }
  },
  { connection, batch: { size: 10 } },
);
```

--------------------------------

### Reuse ioredis Instance for Multiple Workers

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/connections.md

Illustrates reusing a single ioredis instance, configured with specific options like `maxRetriesPerRequest`, across multiple BullMQ Worker instances. This pattern is useful for sharing a connection among multiple consumers, though workers internally manage blocking connections.

```typescript
import { Worker } from 'bullmq';
import IORedis from 'ioredis';

const connection = new IORedis({ maxRetriesPerRequest: null });

// Reuse the ioredis instance in 2 different consumers
const myFirstWorker = new Worker('myFirstWorker', async job => {}, {
  connection,
});
const mySecondWorker = new Worker('mySecondWorker', async job => {}, {
  connection,
});
```

--------------------------------

### Inject BullMQ FlowProducer into NestJS Service

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/producers.md

Illustrates injecting a BullMQ `FlowProducer` into a NestJS service using the `@InjectFlowProducer()` decorator. This enables the service to manage complex job flows with parent-child relationships. It requires the `bullmq` package and NestJS DI.

```typescript
import { Injectable } from '@nestjs/common';
import { InjectFlowProducer } from '@nestjs/bullmq';
import { FlowProducer } from 'bullmq';

@Injectable()
export class FlowService {
  constructor(
    @InjectFlowProducer('flow') private fooFlowProducer: FlowProducer,
  ) {}
}
```

--------------------------------

### Add Job with Jitter Backoff Strategy in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet shows how to add a job to a BullMQ queue and specify the custom 'jitter' backoff strategy. The job is configured to have 3 attempts, and the backoff type is set to 'jitter'.

```typescript
myQueue.add({foo: 'bar'}, {
  attempts: 3,
  backoff: {
    type: 'jitter'
  }
});
```

--------------------------------

### Define Jitter Backoff Strategy in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet demonstrates how to define a custom 'jitter' backoff strategy for BullMQ. The strategy adds a random delay between 0 and 500ms to a base 5000ms delay. It's configured within the queue's settings.

```typescript
const Queue = require('bull');

const myQueue = new Queue('Server B', {
  settings: {
    backoffStrategies: {
      jitter: function (attemptsMade, err) {
        return 5000 + Math.random() * 500;
      }
    }
  }
});
```

--------------------------------

### BullMQ Simple Mode Deduplication (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

Adds a job to the queue with a deduplication ID. If a job with the same ID is already in progress (not completed or failed), subsequent jobs with that ID will be ignored and a '_deduplicated' event will be triggered. Useful for long-running or critical jobs.

```typescript
await myQueue.add(
  'house',
  { color: 'white' },
  { deduplication: { id: 'customValue' } },
);
```

--------------------------------

### Remove Deduplication Key When Job is Active (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/deduplication.md

This snippet shows how to stop deduplicating a job once it becomes active. It imports necessary components from BullMQ, initializes a Queue and Worker, and demonstrates calling `removeDeduplicationKey` within the worker's job processing logic. The `deduplication` option is used when adding the job.

```typescript
import { Job, Queue, Worker } from 'bullmq';

const myQueue = new Queue('Paint');

const worker = new Worker('Paint', async (job: Job) => {
  await myQueue.removeDeduplicationKey(job.deduplicationId)
  console.log('Do something with job');
  return 'some value';
});

myQueue.add('house', { color: 'white' }, { deduplication: { id: 'house'} });
```

--------------------------------

### Define Error-Based Backoff Strategy in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bull/patterns/custom-backoff-strategy.md

This snippet defines a custom backoff strategy named 'foo' in BullMQ that varies the retry delay based on the type of error thrown. If the error is an instance of 'MySpecificError', it delays for 10000ms; otherwise, it delays for 1000ms.

```typescript
const Queue = require('bull');

function MySpecificError() {};

const myQueue = new Queue('Server C', {
  settings: {
    backoffStrategies: {
      foo: function (attemptsMade, err) {
        if (err instanceof MySpecificError) {
          return 10000;
        }
        return 1000;
      }
    }
  }
});
```

--------------------------------

### Set Local Group Rate Limit in BullMQ Pro (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/local-group-rate-limit.md

This snippet shows how to set a specific rate limit for a named group in BullMQ Pro. It requires initializing a QueuePro instance and then calling `setGroupRateLimit` with the group ID, maximum jobs, and duration. A WorkerPro instance must also be configured with a default group limit.

```typescript
import { QueuePro, WorkerPro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue', { connection });
const groupId = 'my group';
const maxJobsPerDuration = 100;

const duration = 1000; // duration in ms.
await queue.setGroupRateLimit(groupId, maxJobsPerDuration, duration);

const worker = new WorkerPro(
  'myQueue',
  async () => {
    // do something
  },
  {
    group: {
      limit: {
        // default rate limit configuration
        max: 1000,
        duration: 1000,
      },
    },
    connection,
  },
);

```

--------------------------------

### BullMQ Throttle Mode Deduplication (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/deduplication.md

Adds a job with a deduplication ID and a Time To Live (TTL). Jobs with the same ID added within the TTL period will be ignored. This prevents overwhelming the queue with rapid, repetitive requests. Requires BullMQ Queue import.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

// Add a job that will be deduplicated for 5 seconds.
await myQueue.add(
  'house',
  { color: 'white' },
  { deduplication: { id: 'customValue', ttl: 5000 } },
);
```

--------------------------------

### Set Per-Job TTL for Cancellation (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/observables/cancelation.md

Allows setting specific Time-To-Live (TTL) values in milliseconds for different job names within BullMQ. This provides granular control over cancellation for distinct job types, ensuring that only specific jobs are cancelled after their defined processing time. It requires importing WorkerPro and connection details.

```typescript
const worker = new WorkerPro(queueName, processor, {
  ttl: { test1: 100, test2: 200 },
  connection,
});
```

--------------------------------

### Register a Flow Producer with BullModule

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/nestjs/README.md

Dynamically registers a flow producer with a specified name using `BullModule.registerFlowProducer()`. This is used for orchestrating complex job flows.

```typescript
BullModule.registerFlowProducer({
  name: 'flowProducerName',
});
```

--------------------------------

### Set Job Scheduler to Stop at endDate

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/repeat-options.md

Defines an expiration date for a job scheduler, after which no more jobs will be created. This is essential for time-bound recurring tasks, ensuring they cease automatically when their intended period concludes. The job will continue to run until the `endDate` is reached.

```typescript
await myQueue.upsertJobScheduler(
  'end-soon-job',
  {
    every: 60000, // every minute
    endDate: new Date('2024-11-01T00:00:00Z'), // end on November 1, 2024
  },
  {
    name: 'timed-end-job',
    data: { message: 'Ending soon' },
  },
);
```

--------------------------------

### Add Delayed Job with Milliseconds Delay - BullMQ TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/delayed.md

Adds a job to the queue with a specified delay in milliseconds. This job will be placed in a 'delayed set' and processed after the delay time has passed. The accuracy of the delay depends on worker availability and other scheduled jobs.

```typescript
import { Queue } from 'bullmq';

const myQueue = new Queue('Paint');

// Add a job that will be delayed by at least 5 seconds.
await myQueue.add('house', { color: 'white' }, { delay: 5000 });
```

--------------------------------

### Manually Rate Limit a Group - TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/rate-limiting.md

Manually rate-limits a group using the `rateLimitGroup` worker method. This is useful when external factors, such as an API returning a 429 error, necessitate rate limiting. Remember to throw `Worker.RateLimitError` after manually rate-limiting.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';

const worker = new WorkerPro(
  'myQueue',
  async job => {
    const groupId = job.opts.group.id;
    const [isRateLimited, duration] = await doExternalCall(groupId);
    if (isRateLimited) {
      await worker.rateLimitGroup(job, duration);
      // Do not forget to throw this special exception,
      // since the job is no longer active after being rate limited.
      throw Worker.RateLimitError();
    }
  },
  {
    connection,
  },
);

// Assume doExternalCall and Worker are defined elsewhere
```

--------------------------------

### Enable Batch Processing with Size in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/batches.md

Configures a BullMQ Pro worker to process jobs in batches. The `batch.size` option specifies the maximum number of jobs to be processed concurrently within a single batch. This worker processes each batched job by calling `doSomethingWithBatchedJob`.

```typescript
const worker = new WorkerPro(
  'My Queue',
  async (job: JobPro) => {
    const batch = job.getBatch();

    for (let i = 0; i < batch.length; i++) {
      const batchedJob = batch[i];
      await doSomethingWithBatchedJob(batchedJob);
    }
  },
  { connection, batch: { size: 10 } },
);
```

--------------------------------

### Add Delayed Job with Specific Future Date - BullMQ TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/delayed.md

Adds a job to the queue to be processed after a specific future date and time. The delay is calculated as the difference between the target time and the current time. The job is then placed in the 'delayed set' and processed once the calculated delay has elapsed.

```typescript
const targetTime = new Date('03-07-2035 10:30');
const delay = Number(targetTime) - Number(new Date());

await myQueue.add('house', { color: 'white' }, { delay });
```

--------------------------------

### Change Job Priority in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/prioritized.md

Shows how to modify the priority of an existing job in BullMQ. This includes changing to a specific numerical priority or enabling LIFO processing for jobs with the same priority.

```typescript
const job = await Job.create(queue, 'test2', { foo: 'bar' }, { priority: 16 });

await job.changePriority({
  priority: 1,
});
```

```typescript
const job = await Job.create(queue, 'test2', { foo: 'bar' }, { priority: 16 });

await job.changePriority({
  lifo: true,
});
```

--------------------------------

### Set Local Group Concurrency in BullMQ Pro (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/local-group-concurrency.md

Sets a specific concurrency value for a given job group in BullMQ Pro. This allows different groups to run with distinct concurrency factors. The value is stored in Redis and should be managed accordingly. Requires the `QueuePro` class from `@taskforcesh/bullmq-pro`.

```typescript
import { QueuePro } from '@taskforcesh/bullmq-pro';

const queue = new QueuePro('myQueue', { connection });
const groupId = 'my group';
await queue.setGroupConcurrency(groupId, 4);
```

--------------------------------

### Add Hierarchical Jobs with FlowProducer

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Demonstrates adding a parent job with multiple child jobs using FlowProducer. The parent job is processed only after all its children are completed. This functionality is available in both TypeScript and Python.

```typescript
import { FlowProducer } from 'bullmq';

const flowProducer = new FlowProducer()

const flow = await flowProducer.add({
  "name": "renovate-interior",
  "queueName": "renovate",
  "children": [
    { "name": "paint", "data": { "place": "ceiling" }, "queueName": "steps" },
    { "name": "paint", "data": { "place": "walls" }, "queueName": "steps" },
    { "name": "fix", "data": { "place": "floor" }, "queueName": "steps" },
  ],
})

```

```python
from bullmq import FlowProducer

flowProducer = FlowProducer()

flow = await flowProducer.add({
  "name": "renovate-interior",
  "queueName": "renovate",
  "children": [
    { "name": "paint", "data": { "place": "ceiling" }, "queueName": "steps" },
    { "name": "paint", "data": { "place": "walls" }, "queueName": "steps" },
    { "name": "fix", "data": { "place": "floor" }, "queueName": "steps" },
  ],
})

```

--------------------------------

### Configure Static Group Rate Limit - TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/rate-limiting.md

Configures a static rate limit for jobs within a group. This limits the maximum number of jobs processed per group within a specified duration. It is set on the worker instance.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';

const worker = new WorkerPro('myQueue', processFn, {
    group: {
      limit: {
        max: 100,  // Limit to 100 jobs per second per group
        duration: 1000,
      }
    },
    connection
});
```

--------------------------------

### Add Job with Custom ID in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/job-ids.md

Demonstrates how to add a job to a BullMQ queue with a custom, user-defined job ID. This requires specifying the `jobId` option when calling the `add` method. Ensure the custom ID does not contain the ':' character.

```typescript
await myQueue.add(
  'wall',
  { color: 'pink' },
  {
    jobId: customJobId,
  },
);
```

--------------------------------

### Configure removeDependencyOnFailure in BullMQ Flow

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/remove-dependency.md

This TypeScript code demonstrates how to configure the 'removeDependencyOnFailure' option when defining a job tree using BullMQ's FlowProducer. It shows how to set this option on child jobs, ensuring that if they fail, their dependency on the parent is automatically removed.

```typescript
const flow = new FlowProducer({ connection });

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name,
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      opts: { removeDependencyOnFailure: true },
      children: [
        {
          name,
          data: { idx: 1, foo: 'bah' },
          queueName: 'grandChildrenQueueName',
        },
        {
          name,
          data: { idx: 2, foo: 'baz' },
          queueName: 'grandChildrenQueueName',
        },
      ],
    },
    {
      name,
      data: { idx: 3, foo: 'foo' },
      queueName: 'childrenQueueName',
    },
  ],
});
```

--------------------------------

### Add Delayed Job to BullMQ Queue (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/README.md

Illustrates adding a job to a BullMQ queue with a specified delay. The job will not be processed until the delay has passed. Note: For BullMQ versions prior to 2.0, a QueueScheduler was required for delayed jobs.

```typescript
await queue.add('paint', { color: 'blue' }, { delay: 5000 });
```

--------------------------------

### Timeout Job Processing with AbortController in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/timeout-jobs.md

This snippet demonstrates how to implement a job timeout in BullMQ using TypeScript. It sets a timeout using `setTimeout` which aborts an `AbortController`. An asynchronous function `doSomethingAbortable` is expected to handle the abort signal. If the operation times out (throws 'AbortError'), an `UnrecoverableError` is thrown; otherwise, the original error is re-thrown. The timer is cleared in the `finally` block.

```typescript
const worker = new Worker('foo', async job => {
  let controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), job.data.timeout);
    
  try {
    await doSomethingAbortable(controller.signal);
  } catch(err) {
     if (err.name == "AbortError") {
      throw new UnrecoverableError("Timeout");
    } else {
      throw err;
    }
  } finally {
    clearTimeout(timer);
  }
});
```

--------------------------------

### BullMQ: Clean Queue Jobs by State (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/removing-jobs.md

Removes jobs from a BullMQ queue that are in a specified state, while respecting a grace period. It allows cleaning a maximum number of jobs. The method returns an array of deleted job IDs.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

const deletedJobIds = await queue.clean(
  60000, // 1 minute grace period
  1000, // max number of jobs to clean
  'paused', // state to clean
);
```

--------------------------------

### Perform Graceful Worker Shutdown in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/graceful-shutdown.md

Initiates a graceful shutdown of a BullMQ worker. The worker will stop accepting new jobs and wait for currently processing jobs to complete or fail. This method does not have a built-in timeout, so ensure jobs finalize promptly. If the shutdown fails, pending jobs are marked as stalled and can be processed by other workers.

```typescript
await worker.close();
```

--------------------------------

### BullMQ: Obliterate Queue and Contents (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/removing-jobs.md

Completely removes a BullMQ queue and all of its associated jobs. Parent jobs in other queues will remain or be moved to 'wait' status depending on their children.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

await queue.obliterate();
```

--------------------------------

### Configure Global Rate Limiter for BullMQ Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/rate-limiting.md

Sets a global rate limit for a BullMQ worker, controlling the maximum number of jobs processed within a specified duration. Jobs exceeding the limit will remain in the waiting state. Note: QueueScheduler is not needed from BullMQ 2.0 onwards.

```typescript
import { Worker, QueueScheduler } from 'bullmq';

const worker = new Worker('painter', async job => paintCar(job), {
  limiter: {
    max: 10,
    duration: 1000,
  },
});

const scheduler = new QueueScheduler('painter');
```

--------------------------------

### Keep Jobs by Age and Count in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/auto-removal-of-jobs.md

Allows BullMQ to retain jobs based on their age (in seconds) and a maximum count. This provides flexible control over job history storage, preventing excessive memory usage.

```typescript
await myQueue.add(
  'test',
  { foo: 'bar' },
  {
    removeOnComplete: {
      age: 3600, // keep up to 1 hour
      count: 1000, // keep up to 1000 jobs
    },
    removeOnFail: {
      age: 24 * 3600, // keep up to 24 hours
    },
  },
);
```

--------------------------------

### Pause BullMQ Worker Locally (Ignoring Running Jobs)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/pausing-queues.md

Locally pauses a BullMQ worker instance immediately, without waiting for the current job to complete. This is done by passing `true` as an argument to the `pause` method on the worker instance.

```typescript
await myWorker.pause(true);
```

--------------------------------

### Remove All Finalized Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/auto-removal-of-jobs.md

Sets `removeOnComplete` and `removeOnFail` to true to automatically delete all jobs once they are finalized. This is the simplest strategy for clearing job history.

```typescript
await myQueue.add(
  'test',
  { foo: 'bar' },
  { removeOnComplete: true, removeOnFail: true },
);
```

--------------------------------

### BullMQ: Keep Finalized Jobs Based on Age (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/auto-removal-of-jobs.md

Configures a BullMQ Worker to retain jobs based on their age and a maximum count. The `removeOnComplete` and `removeOnFail` options accept an object with `age` (in seconds) and `count` properties. This prevents Redis from filling up with old job data.

```typescript
const myWorker = new Worker(
  'myQueueName',
  async job => {
    // do some work
  },
  {
    connection,
    removeOnComplete: {
      age: 3600, // keep up to 1 hour
      count: 1000, // keep up to 1000 jobs
    },
    removeOnFail: {
      age: 24 * 3600, // keep up to 24 hours
    }
  },
);

```

--------------------------------

### Configure Max Concurrent Jobs Per Group in BullMQ (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/concurrency.md

This snippet shows how to set a maximum concurrency limit for jobs belonging to the same group in BullMQ using the WorkerPro class. It limits the number of parallel jobs processed simultaneously for any given group, ensuring controlled resource utilization. Dependencies include '@taskforcesh/bullmq-pro'.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';

const worker = new WorkerPro('myQueue', processFn, {
  group: {
    concurrency: 3, // Limit to max 3 parallel jobs per group
  },
  concurrency: 100,
  connection,
});
```

--------------------------------

### Set Global TTL for Job Cancellation (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/observables/cancelation.md

Configures a BullMQ worker to automatically cancel jobs that exceed a specified global Time-To-Live (TTL) in milliseconds. This prevents jobs from processing indefinitely. It requires importing WorkerPro and providing connection details.

```typescript
import { WorkerPro } from '@taskforcesh/bullmq-pro';

const worker = new WorkerPro(queueName, processor, {
  ttl: 100,
  connection,
});
```

--------------------------------

### Pause Job Group

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/pausing-groups.md

Pauses a specific job group globally. Workers will not pick up new jobs from this group until it's resumed. Currently busy workers will finish their jobs.

```APIDOC
## POST /queue/{queueName}/pauseGroup

### Description
Pauses a job group globally. Workers will not pick up jobs belonging to the paused group. Jobs currently being processed will complete.

### Method
POST

### Endpoint
`/queue/{queueName}/pauseGroup`

### Parameters
#### Path Parameters
- **queueName** (string) - Required - The name of the queue.

#### Query Parameters
- **groupId** (string) - Required - The ID of the group to pause.

### Request Example
```json
{
  "groupId": "myGroupId"
}
```

### Response
#### Success Response (200)
- **success** (boolean) - True if the group was successfully paused, false if it was already paused.

#### Response Example
```json
{
  "success": true
}
```
```

--------------------------------

### Remove Job in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Removes a job from the queue. This can be done using either the `Job` instance or the `Queue` instance. Removing a parent job also removes its children. Removing a child job updates the parent's dependencies.

```typescript
await job.remove();
```

```typescript
await queue.remove(job.id);
```

--------------------------------

### Stop Job Retries with UnrecoverableError in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/stop-retrying-jobs.md

This code snippet demonstrates how to prevent BullMQ from retrying a job by throwing an `UnrecoverableError`. When this error is thrown, BullMQ moves the job directly to the failed set without any further attempts, regardless of the configured `attempts` settings.

```typescript
import { Worker, UnrecoverableError } from 'bullmq';

const worker = new Worker(
  'foo',
  async job => {
    doSomeProcessing();
    throw new UnrecoverableError('Unrecoverable');
  },
  { connection },
);

await queue.add(
  'test-retry',
  { foo: 'bar' },
  {
    attempts: 3,
    backoff: 1000,
  },
);
```

--------------------------------

### Process Child Job Results in Parent Worker

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/README.md

Shows how a parent worker can access and process the results generated by its child jobs using the `getChildrenValues` method. This is useful for aggregating data or performing actions based on child job outcomes. Implemented in TypeScript.

```typescript
import { Worker } from 'bullmq';

const renovateWorker = new Worker('renovate', async job => {
  const childrenValues = await job.getChildrenValues();

  const totalCosts = Object.values(childrenValues).reduce(
    (prev, cur) => prev + cur,
    0,
  );

  await sendInvoice(totalCosts);
});

```

--------------------------------

### Keep a Certain Number of Jobs in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/auto-removal-of-jobs.md

Configures BullMQ to keep a specified maximum number of completed or failed jobs. This is useful for retaining recent job data for inspection while managing storage.

```typescript
await myQueue.add(
  'test',
  { foo: 'bar' },
  { removeOnComplete: 1000, removeOnFail: 5000 },
);
```

--------------------------------

### Add Prioritized Job to a Group in TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/prioritized.md

Adds a job to a queue with a specified group ID and priority. This functionality requires BullMQ Pro. Jobs with higher priority numbers have lower priority. Jobs without explicit priority are assigned the highest priority.

```typescript
await myQueue.add(
  'paint',
  { foo: 'bar' },
  {
    group: {
      id: 'groupId',
      priority: 10,
    },
  },
);
```

--------------------------------

### BullMQ: Remove All Finalized Jobs (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/auto-removal-of-jobs.md

Configures a BullMQ Worker to remove all completed or failed jobs immediately after they are finalized. This is achieved by setting `removeOnComplete` and `removeOnFail` to `{ count: 0 }`. Jobs are deleted regardless of their names.

```typescript
const myWorker = new Worker(
  'myQueueName',
  async job => {
    // do some work
  },
  {
    connection,
    removeOnFail: { count: 0 }
  },
);

```

--------------------------------

### Remove Rate Limit Key from BullMQ Queue

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/rate-limiting.md

Removes the rate limit key from a BullMQ queue, effectively stopping any ongoing rate limit delays and resetting the rate limit counter. This allows workers to resume picking up jobs immediately.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('myQueue', { connection });

await queue.removeRateLimitKey();
```

--------------------------------

### BullMQ: Keep a Specific Number of Finalized Jobs (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/auto-removal-of-jobs.md

Configures a BullMQ Worker to retain a specified number of completed and failed jobs. The `count` option within `removeOnComplete` and `removeOnFail` determines the maximum number of jobs to keep. This is useful for debugging or monitoring.

```typescript
const myWorker = new Worker(
  'myQueueName',
  async job => {
    // do some work
  },
  {
    connection,
    removeOnComplete: { count: 1000 },
    removeOnFail: { count: 5000 }
  },
);

```

--------------------------------

### Pause BullMQ Queue Globally

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/pausing-queues.md

Globally pauses a BullMQ queue, preventing workers from picking up new jobs. Workers currently processing jobs will complete them before idling. This is done by calling the `pause` method on a queue instance.

```typescript
await myQueue.pause();
```

--------------------------------

### BullMQ: Drain Queue Jobs (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/removing-jobs.md

Removes all jobs that are waiting or delayed in a BullMQ queue. Active, waiting-children, completed, or failed jobs are not affected. Parent jobs may be kept in a 'waiting-children' status if they have pending children.

```typescript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

await queue.drain();
```

--------------------------------

### Pause BullMQ Worker Locally

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/workers/pausing-queues.md

Locally pauses a specific BullMQ worker instance. The worker will finish its current job but will not pick up new ones. This functionality is achieved by calling the `pause` method on a worker instance.

```typescript
await myWorker.pause();
```

--------------------------------

### Remove Child Dependency in BullMQ using TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/flows/remove-child-dependency.md

Demonstrates how to remove a child job's dependency from its parent using the `removeChildDependency` method in BullMQ. This is useful for managing complex job flows where a child job no longer needs to wait for its parent. The method ensures that if the child was the last pending dependency, the parent job's state is updated to 'waiting' and it's removed from the parent's unprocessed list.

```typescript
const flow = new FlowProducer({ connection });

const originalTree = await flow.add({
  name: 'root-job',
  queueName: 'topQueueName',
  data: {},
  children: [
    {
      name,
      data: { idx: 0, foo: 'bar' },
      queueName: 'childrenQueueName',
      opts: {},
    },
  ],
});

await originalTree.children[0].job.removeChildDependency();
```

--------------------------------

### Pause a Job Group in BullMQ Pro

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/bullmq-pro/groups/pausing-groups.md

Pauses a specific job group by calling the `pauseGroup` method on a Queue instance. Workers will not pick up new jobs from this group until it's resumed. Returns `false` if the group is already paused.

```typescript
await myQueue.pauseGroup('groupId');
```

--------------------------------

### Change Delay of Existing Delayed Job - BullMQ TypeScript

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/delayed.md

Modifies the delay of a job that is currently in the 'delayed' state. This method allows you to postpone or bring forward the processing time of an already scheduled delayed job. It requires the job object and the new delay in milliseconds.

```typescript
const job = await Job.create(queue, 'test', { foo: 'bar' }, { delay: 2000 });

await job.changeDelay(4000);
```

--------------------------------

### Set BullMQ Global Concurrency (TypeScript)

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/queues/global-concurrency.md

Sets the maximum number of jobs that can be processed in parallel across all worker instances for a BullMQ queue. This value acts as an upper limit for any individual worker's concurrency.

```typescript
import { Queue } from 'bullmq';

await queue.setGlobalConcurrency(4);
```

--------------------------------

### Remove a Job in TypeScript and Python

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/jobs/removing-job.md

Demonstrates how to remove a specific job from a BullMQ queue using both TypeScript and Python. This is useful for cleaning up jobs with invalid data or those that are no longer needed. Locked jobs cannot be removed and will throw an error.

```TypeScript
import { Queue } from 'bullmq';

const queue = new Queue('paint');

const job = await queue.add('wall', { color: 1 });

await job.remove();
```

```Python
from bullmq import Queue

queue = Queue('paint')

job = await queue.add('wall', {'color': 1})

await job.remove()
```

--------------------------------

### Extend Job Lock Manually in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/patterns/manually-fetching-jobs.md

When processing jobs manually, the automatic lock renewal mechanism is not present. This snippet demonstrates how to manually extend a job's lock using `job.extendLock(token, duration)`. This prevents the job from being moved back to the waiting list if processing takes longer than the initial lock duration.

```typescript
const job = (await worker.getNextJob(token)) as Job;

// Extend the lock 30 more seconds
await job.extendLock(token, 30000);
```

--------------------------------

### Remove Job Scheduler in BullMQ

Source: https://github.com/taskforcesh/bullmq/blob/master/docs/gitbook/guide/job-schedulers/manage-job-schedulers.md

The `removeJobScheduler` method deletes a specific job scheduler from the queue using its ID. It returns `true` if a scheduler was removed, and `false` otherwise. This is useful for cleaning up unused or obsolete scheduled tasks.

```typescript
const result = await queue.removeJobScheduler('scheduler-123');
console.log(
  result ? 'Scheduler removed successfully' : 'Missing Job Scheduler'
);
```